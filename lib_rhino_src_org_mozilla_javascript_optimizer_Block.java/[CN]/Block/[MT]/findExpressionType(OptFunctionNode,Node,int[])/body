{
switch (n.getType()) {
case Token.NUMBER:
    return Optimizer.NumberType;
case Token.CALL:
case Token.NEW:
case Token.REF_CALL:
  return Optimizer.AnyType;
case Token.GETELEM:
case Token.GETPROP:
case Token.NAME:
case Token.THIS:
return Optimizer.AnyType;
case Token.GETVAR:
return varTypes[fn.getVarIndex(n)];
case Token.INC:
case Token.DEC:
case Token.MUL:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.BITNOT:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.SUB:
case Token.POS:
case Token.NEG:
return Optimizer.NumberType;
case Token.VOID:
return Optimizer.AnyType;
case Token.FALSE:
case Token.TRUE:
case Token.EQ:
case Token.NE:
case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
case Token.SHEQ:
case Token.SHNE:
case Token.NOT:
case Token.INSTANCEOF:
case Token.IN:
case Token.DEL_REF:
case Token.DELPROP:
return Optimizer.AnyType;
case Token.STRING:
case Token.TYPEOF:
case Token.TYPEOFNAME:
return Optimizer.AnyType;
case Token.NULL:
case Token.REGEXP:
case Token.ARRAYCOMP:
case Token.ARRAYLIT:
case Token.OBJECTLIT:
return Optimizer.AnyType;
case Token.ADD:
{
Node child=n.getFirstChild();
int lType=findExpressionType(fn,child,varTypes);
int rType=findExpressionType(fn,child.getNext(),varTypes);
return lType | rType;
}
case Token.HOOK:
{
Node ifTrue=n.getFirstChild().getNext();
Node ifFalse=ifTrue.getNext();
int ifTrueType=findExpressionType(fn,ifTrue,varTypes);
int ifFalseType=findExpressionType(fn,ifFalse,varTypes);
return ifTrueType | ifFalseType;
}
case Token.COMMA:
case Token.SETVAR:
case Token.SETNAME:
case Token.SETPROP:
case Token.SETELEM:
return findExpressionType(fn,n.getLastChild(),varTypes);
case Token.AND:
case Token.OR:
{
Node child=n.getFirstChild();
int lType=findExpressionType(fn,child,varTypes);
int rType=findExpressionType(fn,child.getNext(),varTypes);
return lType | rType;
}
}
return Optimizer.AnyType;
}
