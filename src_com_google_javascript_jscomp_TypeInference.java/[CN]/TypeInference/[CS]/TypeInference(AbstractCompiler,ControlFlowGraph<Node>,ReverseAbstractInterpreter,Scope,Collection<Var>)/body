{
  super(cfg,new LinkedFlowScope.FlowScopeJoinOp());
  this.compiler=compiler;
  this.registry=compiler.getTypeRegistry();
  this.reverseInterpreter=reverseInterpreter;
  this.syntacticScope=functionScope;
  this.functionScope=LinkedFlowScope.createEntryLattice(functionScope);
  for (  Var unflowableVar : unflowableVars) {
    String name=unflowableVar.getName();
    if (functionScope.getVar(name) == unflowableVar) {
      this.unflowableVarNames.add(name);
    }
  }
  Iterator<Var> varIt=functionScope.getVars();
  while (varIt.hasNext()) {
    Var var=varIt.next();
    if (this.unflowableVarNames.contains(var.getName())) {
      continue;
    }
    if (var.getParentNode() != null && var.getType() == null && var.getParentNode().getType() == Token.VAR && !var.isExtern()) {
      this.functionScope.inferSlotType(var.getName(),getNativeType(VOID_TYPE));
    }
  }
  this.bottomScope=LinkedFlowScope.createEntryLattice(new Scope(functionScope.getRootNode(),functionScope.getTypeOfThis()));
}
