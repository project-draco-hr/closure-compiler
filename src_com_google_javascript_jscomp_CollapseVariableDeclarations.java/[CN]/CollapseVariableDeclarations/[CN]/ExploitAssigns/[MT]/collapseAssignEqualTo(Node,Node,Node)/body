{
  Node assign=expr.getFirstChild();
  Node parent=exprParent;
  Node next=expr.getNext();
  while (next != null) {
switch (next.getType()) {
case Token.AND:
case Token.OR:
case Token.HOOK:
case Token.IF:
case Token.RETURN:
case Token.EXPR_RESULT:
      parent=next;
    next=next.getFirstChild();
  break;
case Token.VAR:
if (next.getFirstChild().hasChildren()) {
  parent=next.getFirstChild();
  next=parent.getFirstChild();
  break;
}
return false;
case Token.GETPROP:
case Token.NAME:
if (next.isQualifiedName()) {
String nextName=next.getQualifiedName();
if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {
if (!isSafeReplacement(next,assign)) {
  return false;
}
exprParent.removeChild(expr);
expr.removeChild(assign);
parent.replaceChild(next,assign);
return true;
}
}
return false;
case Token.NUMBER:
case Token.TRUE:
case Token.FALSE:
case Token.NULL:
case Token.STRING:
if (value.getType() == next.getType()) {
if ((next.getType() == Token.STRING || next.getType() == Token.NUMBER) && !next.isEquivalentTo(value)) {
return false;
}
exprParent.removeChild(expr);
expr.removeChild(assign);
parent.replaceChild(next,assign);
return true;
}
return false;
case Token.ASSIGN:
Node leftSide=next.getFirstChild();
if (leftSide.getType() == Token.NAME || leftSide.getType() == Token.GETPROP && leftSide.getFirstChild().getType() == Token.THIS) {
parent=next;
next=leftSide.getNext();
break;
}
 else {
return false;
}
default :
return false;
}
}
return false;
}
