{
switch (n.getType()) {
case Token.NAME:
case Token.GETPROP:
    if (parent.isGetProp()) {
      return;
    }
 else     if (parent.isFunction()) {
      return;
    }
 else     if (parent.isAssign()) {
      return;
    }
  if (isLocalNameReference(t,n)) {
    return;
  }
if (isPrototypeNameReference(n)) {
  recordPrototypePropUse(t,n,parent);
}
 else if (isStaticNameReference(n,t.getScope())) {
  recordStaticNameUse(t,n,parent);
}
 else {
  recordUnknownUse(t,n,parent);
}
break;
case Token.ASSIGN:
Node lhs=n.getFirstChild();
Node rhs=n.getLastChild();
if (rhs.isFunction()) {
return;
}
if (lhs.isName() || lhs.isGetProp() || rhs.isGetProp()) {
if (NodeUtil.isPrototypeProperty(lhs)) {
Name name=recordPrototypePropDefinition(t,lhs,getType(rhs),n,parent,parent.getParent());
name.setAliased(true);
}
}
maybeAliasNamesOnAssign(lhs,rhs);
break;
case Token.VAR:
Node varName=n.getFirstChild();
Node assignedValue=varName.getFirstChild();
if (assignedValue == null) {
return;
}
maybeAliasNamesOnAssign(varName,assignedValue);
break;
case Token.CALL:
Node param=n.getFirstChild();
while ((param=param.getNext()) != null) {
if (param.isName() || param.isGetProp()) {
safeAlias(param);
}
}
maybeRecordExport(n);
break;
}
}
