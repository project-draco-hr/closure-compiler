{
  if (!n.isFunction() || !n.getLastChild().isBlock()) {
    return;
  }
  Node paramList=n.getChildAtIndex(1);
  final CollectReferences collector=new CollectReferences();
  NodeTraversal.traverse(compiler,paramList,new NodeTraversal.AbstractPreOrderCallback(){
    @Override public final boolean shouldTraverse(    NodeTraversal t,    Node n,    Node parent){
      if (parent == null) {
        return true;
      }
      if (parent.isDefaultValue() && n == parent.getLastChild() || parent.isComputedProp() && n == parent.getFirstChild()) {
        NodeTraversal.traverse(compiler,n,collector);
        return false;
      }
      return true;
    }
  }
);
  Node block=paramList.getNext();
  Es6SyntacticScopeCreator creator=new Es6SyntacticScopeCreator(compiler);
  Scope fScope=creator.createScope(n,t.getScope());
  Scope fBlockScope=creator.createScope(block,fScope);
  Map<String,String> currFuncRenameMap=new HashMap<>();
  for (Iterator<Var> it=fBlockScope.getVars(); it.hasNext(); ) {
    Var var=it.next();
    String oldName=var.getName();
    if (collector.currFuncReferences.contains(oldName) && !currFuncRenameMap.containsKey(oldName)) {
      currFuncRenameMap.put(oldName,oldName + "$" + compiler.getUniqueNameIdSupplier().get());
    }
  }
  Map<Node,Map<String,String>> renameMap=new LinkedHashMap<>();
  renameMap.put(fBlockScope.rootNode,currFuncRenameMap);
  new NodeTraversal(compiler,new Es6RenameReferences(renameMap)).traverseInnerNode(block,block.getParent(),fScope);
}
