{
  final TypeCheck checker=new TypeCheck(compiler,new SemanticReverseAbstractInterpreter(compiler.getCodingConvention(),compiler.getTypeRegistry()),compiler.getTypeRegistry());
  return new CompilerPass(){
    @Override public void process(    Node externs,    Node root){
      checker.processForTesting(externs,root);
      Map<String,CheckLevel> propertiesToErrorFor=Maps.<String,CheckLevel>newHashMap();
      propertiesToErrorFor.put("foobar",CheckLevel.ERROR);
      if (runTightenTypes) {
        TightenTypes tightener=new TightenTypes(compiler);
        tightener.process(externs,root);
        lastPass=DisambiguateProperties.forConcreteTypeSystem(compiler,tightener,propertiesToErrorFor);
      }
 else {
        lastPass=DisambiguateProperties.forJSTypeSystem(compiler,propertiesToErrorFor);
      }
      lastPass.process(externs,root);
    }
  }
;
}
