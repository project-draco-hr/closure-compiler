{
switch (n.getType()) {
case Token.GETPROP:
    Node propNode=n.getFirstChild().getNext();
  if (propNode.isString()) {
    maybeMarkCandidate(propNode);
  }
break;
case Token.OBJECTLIT:
for (Node key=n.getFirstChild(); key != null; key=key.getNext()) {
if (!key.isQuotedString()) {
  maybeMarkCandidate(key);
}
 else {
  quotedNames.add(key.getString());
}
}
break;
case Token.GETELEM:
Node child=n.getLastChild();
if (child != null && child.isString()) {
quotedNames.add(child.getString());
}
break;
case Token.CALL:
Node fnName=n.getFirstChild();
if (fnName.isName() && RENAME_PROPERTY_FUNCTION_NAME.equals(fnName.getString())) {
callNodeToParentMap.put(n,parent);
countCallCandidates(t,n);
}
break;
case Token.FUNCTION:
if (NodeUtil.isFunctionDeclaration(n)) {
String name=n.getFirstChild().getString();
if (RENAME_PROPERTY_FUNCTION_NAME.equals(name)) {
if (parent.isExprResult()) {
parent.detachFromParent();
}
 else {
parent.removeChild(n);
}
compiler.reportCodeChange();
}
}
 else if (parent.isName() && RENAME_PROPERTY_FUNCTION_NAME.equals(parent.getString())) {
Node varNode=parent.getParent();
if (varNode.isVar()) {
varNode.removeChild(parent);
if (!varNode.hasChildren()) {
varNode.detachFromParent();
}
compiler.reportCodeChange();
}
}
break;
}
}
