{
switch (n.getType()) {
case Token.GETPROP:
    Node propNode=n.getSecondChild();
  if (propNode.isString()) {
    maybeMarkCandidate(propNode);
  }
break;
case Token.OBJECTLIT:
for (Node key=n.getFirstChild(); key != null; key=key.getNext()) {
if (!key.isQuotedString()) {
  maybeMarkCandidate(key);
}
 else {
  quotedNames.add(key.getString());
}
}
break;
case Token.GETELEM:
Node child=n.getLastChild();
if (child != null && child.isString()) {
quotedNames.add(child.getString());
}
break;
case Token.CALL:
{
Node fnName=n.getFirstChild();
if (compiler.getCodingConvention().isPropertyRenameFunction(fnName.getOriginalQualifiedName())) {
callNodeToParentMap.put(n,parent);
countCallCandidates(t,n);
}
break;
}
case Token.FUNCTION:
{
if (NodeUtil.isFunctionDeclaration(n)) {
String name=n.getFirstChild().getString();
if (NodeUtil.JSC_PROPERTY_NAME_FN.equals(name)) {
if (parent.isExprResult()) {
parent.detachFromParent();
}
 else {
parent.removeChild(n);
}
compiler.reportCodeChange();
}
}
 else if (parent.isName() && NodeUtil.JSC_PROPERTY_NAME_FN.equals(parent.getString())) {
Node varNode=parent.getParent();
if (varNode.isVar()) {
varNode.removeChild(parent);
if (!varNode.hasChildren()) {
varNode.detachFromParent();
}
compiler.reportCodeChange();
}
}
 else if (NodeUtil.isFunctionExpression(n) && parent.isAssign() && parent.getFirstChild().isGetProp()&& compiler.getCodingConvention().isPropertyRenameFunction(parent.getFirstChild().getOriginalQualifiedName())) {
Node exprResult=parent.getParent();
if (exprResult.isExprResult() && NodeUtil.isStatementBlock(exprResult.getParent()) && exprResult.getFirstChild().isAssign()) {
exprResult.detachFromParent();
compiler.reportCodeChange();
}
}
break;
}
}
}
