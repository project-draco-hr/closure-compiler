{
  if (Objects.equal(enums1,enums2)) {
    return new JSType(newMask,newLocation,newObjs,newTypevar,enums1);
  }
  ImmutableSet.Builder<EnumType> enumBuilder=ImmutableSet.builder();
  ImmutableSet<EnumType> allEnums=EnumType.union(enums1,enums2);
  for (  EnumType e : allEnums) {
    if (enums1 != null && enums1.contains(e) && enums2 != null && enums2.contains(e)) {
      enumBuilder.add(e);
      continue;
    }
    JSType enumeratedType=e.getEnumeratedType();
    if (enumeratedType.isUnknown()) {
      enumBuilder.add(e);
      continue;
    }
    if (enumeratedType.mask != NON_SCALAR_MASK) {
      if ((enumeratedType.mask & unionMask) != 0) {
        enumBuilder.add(e);
        newMask&=~enumeratedType.mask;
      }
    }
 else     if (objs1 != null || objs2 != null) {
      Set<ObjectType> objsToRemove=Sets.newHashSet();
      ObjectType enumObj=Iterables.getOnlyElement(enumeratedType.objs);
      if (objs1 != null) {
        for (        ObjectType obj1 : objs1) {
          if (enumObj.isSubtypeOf(obj1)) {
            enumBuilder.add(e);
            objsToRemove.add(obj1);
          }
        }
      }
      if (objs2 != null) {
        for (        ObjectType obj2 : objs2) {
          if (enumObj.isSubtypeOf(obj2)) {
            enumBuilder.add(e);
            objsToRemove.add(obj2);
          }
        }
      }
      if (!objsToRemove.isEmpty() && newObjs != null) {
        newObjs=Sets.difference(newObjs,objsToRemove).immutableCopy();
      }
    }
  }
  return new JSType(newMask,newLocation,newObjs,newTypevar,enumBuilder.build());
}
