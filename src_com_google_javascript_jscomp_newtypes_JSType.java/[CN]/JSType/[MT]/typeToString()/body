{
switch (mask) {
case BOTTOM_MASK:
    return "bottom";
case TOP_MASK:
  return "*";
case UNKNOWN_MASK:
return "?";
default :
int tags=mask;
StringBuilder sb=new StringBuilder();
boolean firstIteration=true;
for (int tag=1; tag != END_MASK; tag<<=1) {
if ((tags & tag) != 0) {
if (!firstIteration) {
sb.append('|');
}
firstIteration=false;
switch (tag) {
case TRUE_MASK:
case FALSE_MASK:
sb.append("boolean");
tags&=~BOOLEAN_MASK;
continue;
case NULL_MASK:
sb.append("null");
tags&=~NULL_MASK;
continue;
case NUMBER_MASK:
sb.append("number");
tags&=~NUMBER_MASK;
continue;
case STRING_MASK:
sb.append("string");
tags&=~STRING_MASK;
continue;
case UNDEFINED_MASK:
sb.append("undefined");
tags&=~UNDEFINED_MASK;
continue;
case TYPEVAR_MASK:
sb.append(typeVar);
tags&=~TYPEVAR_MASK;
continue;
case NON_SCALAR_MASK:
{
if (objs.size() == 1) {
sb.append(Iterables.getOnlyElement(objs).toString());
}
 else {
Set<String> strReps=Sets.newTreeSet();
for (ObjectType obj : objs) {
strReps.add(obj.toString());
}
PIPE_JOINER.appendTo(sb,strReps);
}
tags&=~NON_SCALAR_MASK;
continue;
}
case ENUM_MASK:
{
if (enums.size() == 1) {
sb.append(Iterables.getOnlyElement(enums).toString());
}
 else {
Set<String> strReps=Sets.newTreeSet();
for (EnumType e : enums) {
strReps.add(e.toString());
}
PIPE_JOINER.appendTo(sb,strReps);
}
tags&=~ENUM_MASK;
continue;
}
}
}
}
if (tags == 0) {
return sb.toString();
}
 else if (tags == TRUTHY_MASK) {
return "truthy";
}
 else if (tags == FALSY_MASK) {
return "falsy";
}
 else {
return "Unrecognized type: " + tags;
}
}
}
