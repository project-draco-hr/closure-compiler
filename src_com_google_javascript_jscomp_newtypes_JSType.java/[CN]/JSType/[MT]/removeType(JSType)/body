{
  int otherMask=other.getMask();
  Preconditions.checkState(!other.isTop() && !other.isUnknown() && (otherMask & TYPEVAR_MASK) == 0 && (otherMask & ENUM_MASK) == 0);
  if (isUnknown()) {
    return this;
  }
  if (isTop()) {
    return ALMOST_TOP.removeType(other);
  }
  int newMask=getMask() & ~otherMask;
  if ((otherMask & NON_SCALAR_MASK) == 0) {
    return new UnionType(newMask,getLocation(),getObjs(),getTypeVar(),getEnums());
  }
  Preconditions.checkState(other.getObjs().size() == 1,"Invalid type to remove: %s",other);
  ObjectType otherObj=Iterables.getOnlyElement(other.getObjs());
  ImmutableSet<ObjectType> newObjs=null;
  ImmutableSet<EnumType> newEnums=null;
  if (getObjs() != null) {
    ImmutableSet.Builder<ObjectType> builder=ImmutableSet.builder();
    for (    ObjectType obj : getObjs()) {
      if (!obj.isSubtypeOf(otherObj)) {
        builder.add(obj);
      }
    }
    newObjs=builder.build();
  }
  if (getEnums() != null) {
    ImmutableSet.Builder<EnumType> builder=ImmutableSet.builder();
    for (    EnumType e : getEnums()) {
      if (!e.getEnumeratedType().isSubtypeOf(other)) {
        builder.add(e);
      }
    }
    newEnums=builder.build();
  }
  return new UnionType(newMask,getLocation(),newObjs,getTypeVar(),newEnums);
}
