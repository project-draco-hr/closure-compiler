{
  if (t1.isUnknown()) {
    return t2;
  }
 else   if (t2.isUnknown()) {
    return t1;
  }
 else   if (t1.isTop() && t2.isTop()) {
    return TOP;
  }
 else   if (t1.isTop() || t2.isTop()) {
    return null;
  }
  ImmutableSet<EnumType> newEnums=null;
  if (t1.getEnums() == null) {
    if (t2.getEnums() != null) {
      return null;
    }
    newEnums=null;
  }
 else   if (t2.getEnums() == null) {
    return null;
  }
 else   if (!t1.getEnums().equals(t2.getEnums())) {
    return null;
  }
 else {
    newEnums=t1.getEnums();
  }
  int t1Mask=promoteBoolean(t1.getMask());
  int t2Mask=promoteBoolean(t2.getMask());
  if (t1Mask != t2Mask || !Objects.equals(t1.getTypeVar(),t2.getTypeVar())) {
    return null;
  }
  if ((t1Mask & NON_SCALAR_MASK) == 0) {
    return t1;
  }
  if (t1.getObjs().size() != t2.getObjs().size()) {
    return null;
  }
  Set<ObjectType> ununified=Sets.newHashSet(t2.getObjs());
  Set<ObjectType> unifiedObjs=Sets.newHashSet();
  for (  ObjectType objType1 : t1.getObjs()) {
    ObjectType unified=objType1;
    boolean hasUnified=false;
    for (    ObjectType objType2 : t2.getObjs()) {
      ObjectType tmp=ObjectType.unifyUnknowns(unified,objType2);
      if (tmp != null) {
        hasUnified=true;
        ununified.remove(objType2);
        unified=tmp;
      }
    }
    if (!hasUnified) {
      return null;
    }
    unifiedObjs.add(unified);
  }
  if (!ununified.isEmpty()) {
    return null;
  }
  return makeType(t1Mask,ImmutableSet.copyOf(unifiedObjs),t1.getTypeVar(),newEnums);
}
