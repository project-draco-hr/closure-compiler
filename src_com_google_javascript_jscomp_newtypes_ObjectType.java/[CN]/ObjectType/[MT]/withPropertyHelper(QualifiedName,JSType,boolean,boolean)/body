{
  PersistentMap<String,Property> newProps=this.props;
  if (qname.isIdentifier()) {
    String pname=qname.getLeftmostName();
    JSType declType=getDeclaredProp(qname);
    if (type == null) {
      type=declType;
    }
    if (declType != null) {
      isDeclared=true;
      if (hasConstantProp(qname)) {
        isConstant=true;
      }
      if (type != null && !type.isSubtypeOf(declType,SubtypeCache.create())) {
        type=declType;
      }
    }
 else     if (isDeclared) {
      declType=type;
    }
    if (type == null && declType == null) {
      newProps=newProps.without(pname);
    }
 else {
      newProps=newProps.with(pname,isConstant ? Property.makeConstant(null,type,declType) : Property.make(type,isDeclared ? declType : null));
    }
  }
 else {
    String objName=qname.getLeftmostName();
    QualifiedName objQname=new QualifiedName(objName);
    if (!mayHaveProp(objQname)) {
      Preconditions.checkState(type == null,"Trying to update property %s on type %s, but sub-property %s does" + " not exist",qname,this,objName);
      return this;
    }
    QualifiedName innerProps=qname.getAllButLeftmost();
    Property objProp=getLeftmostProp(objQname);
    JSType inferred=type == null ? objProp.getType().withoutProperty(innerProps) : objProp.getType().withProperty(innerProps,type);
    JSType declared=objProp.getDeclaredType();
    newProps=newProps.with(objName,objProp.isOptional() ? Property.makeOptional(null,inferred,declared) : Property.make(inferred,declared));
  }
  return ObjectType.makeObjectType(nominalType,newProps,fn,isLoose,objectKind);
}
