{
  int[] aRanges=ranges, bRanges=other.ranges;
  int aLen=aRanges.length, bLen=bRanges.length;
  if (aLen == 0) {
    return this;
  }
  if (bLen == 0) {
    return other;
  }
  int aIdx=0, bIdx=0;
  int[] intersection=new int[Math.min(aLen,bLen)];
  int intersectionIdx=0;
  int pos=Math.min(aRanges[0],bRanges[0]);
  while (aIdx < aLen && bIdx < bLen) {
    if (aRanges[aIdx + 1] <= pos) {
      aIdx+=2;
    }
 else     if (bRanges[bIdx + 1] <= pos) {
      bIdx+=2;
    }
 else {
      int start=Math.max(aRanges[aIdx],bRanges[bIdx]);
      if (pos < start) {
        pos=start;
      }
 else {
        int end=Math.min(aRanges[aIdx + 1],bRanges[bIdx + 1]);
        if (intersectionIdx != 0 && pos == intersection[intersectionIdx - 1]) {
          intersection[intersectionIdx - 1]=end;
        }
 else {
          if (intersectionIdx == intersection.length) {
            int[] newArr=new int[intersectionIdx * 2];
            System.arraycopy(intersection,0,newArr,0,intersectionIdx);
            intersection=newArr;
          }
          intersection[intersectionIdx++]=pos;
          intersection[intersectionIdx++]=end;
        }
        pos=end;
      }
    }
  }
  if (intersectionIdx != intersection.length) {
    int[] newArr=new int[intersectionIdx];
    System.arraycopy(intersection,0,newArr,0,intersectionIdx);
    intersection=newArr;
  }
  return new CharRanges(intersection);
}
