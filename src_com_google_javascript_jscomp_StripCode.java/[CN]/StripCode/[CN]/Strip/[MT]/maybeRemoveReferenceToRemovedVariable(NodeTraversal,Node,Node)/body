{
switch (parent.getType()) {
case Token.VAR:
    break;
case Token.GETPROP:
case Token.GETELEM:
  if (parent.getFirstChild() == n && isReferenceToRemovedVar(t,n)) {
    replaceHighestNestedCallWithNull(parent,parent.getParent());
  }
break;
case Token.ASSIGN:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_ADD:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
if (isReferenceToRemovedVar(t,n)) {
if (parent.getFirstChild() == n) {
  Node grandparent=parent.getParent();
  if (grandparent.isExprResult()) {
    Node greatGrandparent=grandparent.getParent();
    replaceWithEmpty(grandparent,greatGrandparent);
    compiler.reportCodeChange();
  }
 else {
    Node rvalue=n.getNext();
    parent.removeChild(rvalue);
    grandparent.replaceChild(parent,rvalue);
    compiler.reportCodeChange();
  }
}
 else {
  replaceWithNull(n,parent);
  compiler.reportCodeChange();
}
}
break;
default :
if (isReferenceToRemovedVar(t,n)) {
replaceWithNull(n,parent);
compiler.reportCodeChange();
}
break;
}
}
