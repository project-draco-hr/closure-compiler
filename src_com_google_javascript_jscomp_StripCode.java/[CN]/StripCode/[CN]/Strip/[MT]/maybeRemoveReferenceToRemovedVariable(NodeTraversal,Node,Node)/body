{
switch (parent.getType()) {
case Token.VAR:
    break;
case Token.GETPROP:
case Token.GETELEM:
  if (parent.getFirstChild() == n && isReferenceToRemovedVar(t,n)) {
    replaceHighestNestedCallWithNull(parent,parent.getParent());
  }
break;
case Token.ASSIGN:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_ADD:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
if (isReferenceToRemovedVar(t,n)) {
if (parent.getFirstChild() == n) {
  Node gramps=parent.getParent();
  if (NodeUtil.isExpressionNode(gramps)) {
    Node greatGramps=gramps.getParent();
    replaceWithEmpty(gramps,greatGramps);
    compiler.reportCodeChange();
  }
 else {
    Node rvalue=n.getNext();
    parent.removeChild(rvalue);
    gramps.replaceChild(parent,rvalue);
    compiler.reportCodeChange();
  }
}
 else {
  replaceWithNull(n,parent);
  compiler.reportCodeChange();
}
}
break;
default :
if (isReferenceToRemovedVar(t,n)) {
replaceWithNull(n,parent);
compiler.reportCodeChange();
}
break;
}
}
