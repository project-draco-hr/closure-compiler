{
  Node parent=callNode.getParent();
  Node grandParent=parent.getParent();
  if (NodeUtil.isExprCall(parent)) {
    return CallSiteType.SIMPLE_CALL;
  }
 else   if (NodeUtil.isExprAssign(grandParent) && NodeUtil.isRValue(callNode) && parent.getFirstChild().getType() == Token.NAME && !NodeUtil.isConstantName(parent.getFirstChild())) {
    return CallSiteType.SIMPLE_ASSIGNMENT;
  }
 else   if (parent.getType() == Token.NAME && !NodeUtil.isConstantName(parent) && grandParent.getType() == Token.VAR && grandParent.hasOneChild()) {
    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;
  }
 else {
    Node expressionRoot=ExpressionDecomposer.findExpressionRoot(callNode);
    if (expressionRoot != null) {
      ExpressionDecomposer decomposer=new ExpressionDecomposer(compiler,safeNameIdSupplier,knownConstants);
      DecompositionType type=decomposer.canExposeExpression(callNode);
      if (type == DecompositionType.MOVABLE) {
        return CallSiteType.EXPRESSION;
      }
 else       if (type == DecompositionType.DECOMPOSABLE) {
        return CallSiteType.DECOMPOSABLE_EXPRESSION;
      }
 else {
        Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE);
      }
    }
  }
  return CallSiteType.UNSUPPORTED;
}
