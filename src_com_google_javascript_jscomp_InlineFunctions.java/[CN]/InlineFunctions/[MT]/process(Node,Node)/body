{
  Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());
  NodeTraversal.traverse(compiler,root,new FindCandidateFunctions());
  if (fns.isEmpty()) {
    return;
  }
  NodeTraversal.traverse(compiler,root,new FindCandidatesReferences(fns,anonFns));
  trimCandidatesNotMeetingMinimumRequirements();
  if (fns.isEmpty()) {
    return;
  }
  Set<String> fnNames=Sets.newHashSet(fns.keySet());
  injector.setKnownConstants(fnNames);
  trimCandidatesUsingOnCost();
  if (fns.isEmpty()) {
    return;
  }
  resolveInlineConflicts();
  decomposeExpressions();
  NodeTraversal.traverse(compiler,root,new CallVisitor(fns,anonFns,new Inline(injector)));
  removeInlinedFunctions();
}
