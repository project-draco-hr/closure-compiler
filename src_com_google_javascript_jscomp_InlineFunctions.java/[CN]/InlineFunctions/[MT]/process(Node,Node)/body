{
  Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());
  NodeTraversal.traverse(compiler,root,new FindCandidateFunctions());
  if (fns.isEmpty()) {
    return;
  }
  NodeTraversal.traverse(compiler,root,new FindCandidatesReferences(fns,anonFns));
  trimCanidatesNotMeetingMinimumRequirements();
  if (fns.isEmpty()) {
    return;
  }
  Set<String> fnNames=Sets.newHashSet(fns.keySet());
  injector.setKnownConstants(fnNames);
  trimCanidatesUsingOnCost();
  if (fns.isEmpty()) {
    return;
  }
  resolveInlineConflicts();
  decomposeExpressions(fnNames);
  NodeTraversal.traverse(compiler,root,new CallVisitor(fns,anonFns,new Inline(injector,specializationState)));
  removeInlinedFunctions();
}
