{
switch (n.getType()) {
case Token.BLOCK:
case Token.FUNCTION:
    return;
case Token.WHILE:
case Token.DO:
case Token.IF:
  computeMustDef(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case Token.FOR:
if (!NodeUtil.isForIn(n)) {
computeMustDef(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
}
 else {
Node lhs=n.getFirstChild();
Node rhs=lhs.getNext();
if (lhs.isVar()) {
  lhs=lhs.getLastChild();
}
if (lhs.isName()) {
  addToDefIfLocal(lhs.getString(),cfgNode,rhs,output);
}
}
return;
case Token.AND:
case Token.OR:
computeMustDef(n.getFirstChild(),cfgNode,output,conditional);
computeMustDef(n.getLastChild(),cfgNode,output,true);
return;
case Token.HOOK:
computeMustDef(n.getFirstChild(),cfgNode,output,conditional);
computeMustDef(n.getSecondChild(),cfgNode,output,true);
computeMustDef(n.getLastChild(),cfgNode,output,true);
return;
case Token.VAR:
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (c.hasChildren()) {
computeMustDef(c.getFirstChild(),cfgNode,output,conditional);
addToDefIfLocal(c.getString(),conditional ? null : cfgNode,c.getFirstChild(),output);
}
}
return;
default :
if (NodeUtil.isAssignmentOp(n)) {
if (n.getFirstChild().isName()) {
Node name=n.getFirstChild();
computeMustDef(name.getNext(),cfgNode,output,conditional);
addToDefIfLocal(name.getString(),conditional ? null : cfgNode,n.getLastChild(),output);
return;
}
 else if (NodeUtil.isGet(n.getFirstChild())) {
Node obj=n.getFirstChild().getFirstChild();
if (obj.isName() && "arguments".equals(obj.getString())) {
escapeParameters(output);
}
}
}
if (n.isName() && "arguments".equals(n.getString())) {
escapeParameters(output);
}
if (n.isDec() || n.isInc()) {
Node target=n.getFirstChild();
if (target.isName()) {
addToDefIfLocal(target.getString(),conditional ? null : cfgNode,null,output);
return;
}
}
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
computeMustDef(c,cfgNode,output,conditional);
}
}
}
