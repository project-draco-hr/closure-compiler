{
  Node assign=expr.getFirstChild();
  Node parent=exprParent;
  Node next=expr.getNext();
  while (next != null) {
switch (next.getToken()) {
case AND:
case OR:
case HOOK:
case IF:
case RETURN:
case EXPR_RESULT:
      parent=next;
    next=next.getFirstChild();
  break;
case VAR:
if (next.getFirstChild().hasChildren()) {
  parent=next.getFirstChild();
  next=parent.getFirstChild();
  break;
}
return false;
case GETPROP:
case NAME:
if (next.isQualifiedName()) {
if (value.isQualifiedName() && next.matchesQualifiedName(value)) {
if (!isSafeReplacement(next,assign)) {
  return false;
}
exprParent.removeChild(expr);
expr.removeChild(assign);
parent.replaceChild(next,assign);
return true;
}
}
return false;
case ASSIGN:
Node leftSide=next.getFirstChild();
if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {
parent=next;
next=leftSide.getNext();
break;
}
 else {
return false;
}
default :
if (NodeUtil.isImmutableValue(next) && next.isEquivalentTo(value)) {
exprParent.removeChild(expr);
expr.removeChild(assign);
parent.replaceChild(next,assign);
return true;
}
return false;
}
}
return false;
}
