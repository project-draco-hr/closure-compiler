{
  Compiler compiler=getCompiler();
  if (knownConstants == null) {
    knownConstants=Sets.newHashSet();
  }
  ExpressionDecomposer decomposer=new ExpressionDecomposer(compiler,compiler.getUniqueNameIdSupplier(),knownConstants,newScope());
  decomposer.setTempNamePrefix("temp");
  decomposer.setResultNamePrefix("result");
  Node expectedRoot=parse(compiler,expectedResult);
  Node tree=parse(compiler,code);
  assertNotNull(tree);
  Node callSite=findCall(tree,fnName);
  assertNotNull("Call to " + fnName + " was not found.",callSite);
  DecompositionType result=decomposer.canExposeExpression(callSite);
  assertEquals(DecompositionType.DECOMPOSABLE,result);
  compiler.resetUniqueNameId();
  decomposer.exposeExpression(callSite);
  validateSourceInfo(compiler,tree);
  String explanation=expectedRoot.checkTreeEquals(tree);
  assertNull("\nExpected: " + compiler.toSource(expectedRoot) + "\nResult: "+ compiler.toSource(tree)+ "\n"+ explanation,explanation);
}
