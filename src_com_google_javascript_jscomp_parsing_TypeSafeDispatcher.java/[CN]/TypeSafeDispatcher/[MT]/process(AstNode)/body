{
switch (node.getType()) {
case Token.ADD:
case Token.AND:
case Token.BITAND:
case Token.BITOR:
case Token.BITXOR:
case Token.COMMA:
case Token.DIV:
case Token.EQ:
case Token.GE:
case Token.GT:
case Token.IN:
case Token.INSTANCEOF:
case Token.LE:
case Token.LSH:
case Token.LT:
case Token.MOD:
case Token.MUL:
case Token.NE:
case Token.OR:
case Token.RSH:
case Token.SHEQ:
case Token.SHNE:
case Token.SUB:
case Token.URSH:
    return processInfixExpression((InfixExpression)node);
case Token.ARRAYLIT:
  return processArrayLiteral((ArrayLiteral)node);
case Token.ASSIGN:
case Token.ASSIGN_ADD:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_DIV:
case Token.ASSIGN_LSH:
case Token.ASSIGN_MOD:
case Token.ASSIGN_MUL:
case Token.ASSIGN_RSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_URSH:
return processAssignment((Assignment)node);
case Token.BITNOT:
case Token.DEC:
case Token.DELPROP:
case Token.INC:
case Token.NEG:
case Token.NOT:
case Token.POS:
case Token.TYPEOF:
case Token.VOID:
return processUnaryExpression((UnaryExpression)node);
case Token.BLOCK:
if (node instanceof Block) {
return processBlock((Block)node);
}
 else if (node instanceof Scope) {
return processScope((Scope)node);
}
 else {
throw new IllegalStateException("Unexpected node type.  class: " + node.getClass() + " type: "+ Token.typeToName(node.getType()));
}
case Token.BREAK:
return processBreakStatement((BreakStatement)node);
case Token.CALL:
return processFunctionCall((FunctionCall)node);
case Token.CASE:
case Token.DEFAULT:
return processSwitchCase((SwitchCase)node);
case Token.CATCH:
case Token.FINALLY:
return processCatchClause((CatchClause)node);
case Token.COLON:
return processObjectProperty((ObjectProperty)node);
case Token.CONTINUE:
return processContinueStatement((ContinueStatement)node);
case Token.DO:
return processDoLoop((DoLoop)node);
case Token.EMPTY:
return processEmptyExpression((EmptyExpression)node);
case Token.EXPR_RESULT:
case Token.EXPR_VOID:
if (node instanceof ExpressionStatement) {
return processExpressionStatement((ExpressionStatement)node);
}
 else if (node instanceof LabeledStatement) {
return processLabeledStatement((LabeledStatement)node);
}
 else {
throw new IllegalStateException("Unexpected node type.  class: " + node.getClass() + " type: "+ Token.typeToName(node.getType()));
}
case Token.DEBUGGER:
case Token.FALSE:
case Token.NULL:
case Token.THIS:
case Token.TRUE:
return processKeywordLiteral((KeywordLiteral)node);
case Token.FOR:
if (node instanceof ForInLoop) {
return processForInLoop((ForInLoop)node);
}
 else if (node instanceof ForLoop) {
return processForLoop((ForLoop)node);
}
 else {
throw new IllegalStateException("Unexpected node type.  class: " + node.getClass() + " type: "+ Token.typeToName(node.getType()));
}
case Token.FUNCTION:
return processFunctionNode((FunctionNode)node);
case Token.GETELEM:
return processElementGet((ElementGet)node);
case Token.GETPROP:
return processPropertyGet((PropertyGet)node);
case Token.HOOK:
return processConditionalExpression((ConditionalExpression)node);
case Token.IF:
return processIfStatement((IfStatement)node);
case Token.LABEL:
return processLabel((Label)node);
case Token.LP:
return processParenthesizedExpression((ParenthesizedExpression)node);
case Token.NAME:
return processName((Name)node);
case Token.NEW:
return processNewExpression((NewExpression)node);
case Token.NUMBER:
return processNumberLiteral((NumberLiteral)node);
case Token.OBJECTLIT:
return processObjectLiteral((ObjectLiteral)node);
case Token.REGEXP:
return processRegExpLiteral((RegExpLiteral)node);
case Token.RETURN:
return processReturnStatement((ReturnStatement)node);
case Token.SCRIPT:
return processAstRoot((AstRoot)node);
case Token.STRING:
return processStringLiteral((StringLiteral)node);
case Token.SWITCH:
return processSwitchStatement((SwitchStatement)node);
case Token.THROW:
return processThrowStatement((ThrowStatement)node);
case Token.TRY:
return processTryStatement((TryStatement)node);
case Token.VAR:
if (node instanceof VariableDeclaration) {
return processVariableDeclaration((VariableDeclaration)node);
}
 else if (node instanceof VariableInitializer) {
return processVariableInitializer((VariableInitializer)node);
}
 else {
throw new IllegalStateException("Unexpected node type.  class: " + node.getClass() + " type: "+ Token.typeToName(node.getType()));
}
case Token.WHILE:
return processWhileLoop((WhileLoop)node);
case Token.WITH:
return processWithStatement((WithStatement)node);
}
return processIllegalToken(node);
}
