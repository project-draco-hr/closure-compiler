{
  if (peek(TokenType.YIELD) && inGeneratorContext()) {
    return parseYield(expressionIn);
  }
  SourcePosition start=getTreeStartLocation();
  GenericTypeListTree generics=maybeParseGenericTypes();
  ParseTree left=parseConditional(expressionIn);
  ParseTree returnType=null;
  if (peek(TokenType.COLON) && mayHaveColonType) {
    colonTypeTokens.add(peekToken());
    returnType=parseTypeAnnotation();
  }
  if (peek(TokenType.ARROW)) {
    FormalParameterListTree params=transformArrowFunctionParameters(start,left);
    colonTypeTokens.clear();
    if (peek(TokenType.COLON)) {
      parseTypeAnnotation();
    }
    return parseArrowFunctionTail(start,generics,params,returnType,expressionIn);
  }
  if (generics != null) {
    reportError("invalid location for generics");
  }
  if (left.type == ParseTreeType.FORMAL_PARAMETER_LIST) {
    reportError("invalid paren expression");
  }
  if (peekAssignmentOperator()) {
    left=transformLeftHandSideExpression(left);
    if (!left.isValidAssignmentTarget()) {
      reportError("invalid assignment target");
    }
    Token operator=nextToken();
    ParseTree right=parseAssignment(expressionIn,mayHaveColonType);
    return new BinaryOperatorTree(getTreeLocation(start),left,operator,right);
  }
  if (peek(TokenType.CLOSE_PAREN)) {
    if (!peek(1,TokenType.ARROW) && !peek(1,TokenType.COLON)) {
      reportInvalidColonTypes();
    }
  }
 else   if (!peek(TokenType.COMMA)) {
    reportInvalidColonTypes();
  }
  return left;
}
