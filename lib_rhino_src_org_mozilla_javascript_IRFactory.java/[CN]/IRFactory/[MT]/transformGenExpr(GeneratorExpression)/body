{
  Node pn;
  FunctionNode fn=new FunctionNode();
  fn.setSourceName(currentScriptOrFn.getNextTempName());
  fn.setIsGenerator();
  fn.setFunctionType(FunctionNode.FUNCTION_EXPRESSION);
  fn.setRequiresActivation();
  int functionType=fn.getFunctionType();
  int start=decompiler.markFunctionStart(functionType);
  Node mexpr=decompileFunctionHeader(fn);
  int index=currentScriptOrFn.addFunction(fn);
  PerFunctionVariables savedVars=new PerFunctionVariables(fn);
  try {
    Node destructuring=(Node)fn.getProp(Node.DESTRUCTURING_PARAMS);
    fn.removeProp(Node.DESTRUCTURING_PARAMS);
    int lineno=node.lineno;
    ++nestingOfFunction;
    Node body=genExprTransformHelper(node);
    if (!fn.isExpressionClosure()) {
      decompiler.addToken(Token.RC);
    }
    fn.setEncodedSourceBounds(start,decompiler.markFunctionEnd(start));
    if (functionType != FunctionNode.FUNCTION_EXPRESSION && !fn.isExpressionClosure()) {
      decompiler.addToken(Token.EOL);
    }
    if (destructuring != null) {
      body.addChildToFront(new Node(Token.EXPR_VOID,destructuring,lineno));
    }
    int syntheticType=fn.getFunctionType();
    pn=initFunction(fn,index,body,syntheticType);
    if (mexpr != null) {
      pn=createAssignment(Token.ASSIGN,mexpr,pn);
      if (syntheticType != FunctionNode.FUNCTION_EXPRESSION) {
        pn=createExprStatementNoReturn(pn,fn.getLineno());
      }
    }
  }
  finally {
    --nestingOfFunction;
    savedVars.restore();
  }
  Node call=createCallOrNew(Token.CALL,pn);
  call.setLineno(node.getLineno());
  decompiler.addToken(Token.LP);
  decompiler.addToken(Token.RP);
  return call;
}
