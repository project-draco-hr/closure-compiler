{
  Node target=null;
  Node fn=null;
  String name=null;
switch (n.getType()) {
case Token.ASSIGN:
    name=n.getFirstChild().getQualifiedName();
  fn=n;
while (fn.isAssign()) {
  fn=fn.getLastChild();
}
target=n.getParent();
break;
case Token.FUNCTION:
name=NodeUtil.getFunctionName(n);
fn=n;
target=n;
break;
case Token.VAR:
case Token.LET:
case Token.CONST:
name=n.getFirstChild().getString();
fn=getDeclarationRValue(n);
target=n;
break;
case Token.MEMBER_FUNCTION_DEF:
Node parent=n.getParent();
if (parent.isClassMembers()) {
Node classNode=parent.getParent();
String midPart=n.isStaticMember() ? "." : ".prototype.";
name=NodeUtil.getClassName(classNode) + midPart + n.getString();
if (n.getString().equals("constructor")) {
name=NodeUtil.getClassName(classNode);
}
fn=n.getFirstChild();
if (classNode.getParent().isAssign() || classNode.getParent().isName()) {
target=classNode.getParent().getParent();
}
 else {
target=classNode;
}
}
break;
}
if (fn == null || !fn.isFunction()) {
compiler.report(t.makeError(n,INJECT_NON_FUNCTION_ERROR));
return;
}
if (!target.getParent().isScript() && !target.getParent().isBlock()) {
compiler.report(t.makeError(n,INJECT_IN_NON_GLOBAL_OR_BLOCK_ERROR));
return;
}
Preconditions.checkNotNull(name);
injectables.add(new NodeContext(name,n,fn,target));
}
