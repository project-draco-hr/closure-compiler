{
  if (nodeFilter != null && !nodeFilter.apply(n)) {
    return;
  }
  if (externsRoot != null && n == externsRoot) {
    externsScope=t.getScope();
  }
  String name;
  boolean isSet=false;
  Name.Type type=Name.Type.OTHER;
  boolean isPropAssign=false;
switch (n.getType()) {
case Token.STRING:
    name=null;
  if (parent != null && parent.getType() == Token.OBJECTLIT) {
    name=getNameForObjLitKey(n);
  }
if (name == null) return;
isSet=true;
type=getValueType(n.getFirstChild());
break;
case Token.NAME:
if (parent != null) {
switch (parent.getType()) {
case Token.VAR:
isSet=true;
Node rvalue=n.getFirstChild();
type=rvalue == null ? Name.Type.OTHER : getValueType(rvalue);
break;
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
}
break;
case Token.GETPROP:
return;
case Token.FUNCTION:
Node gramps=parent.getParent();
if (gramps == null || NodeUtil.isFunctionExpression(parent)) return;
isSet=true;
type=Name.Type.FUNCTION;
break;
}
}
name=n.getString();
break;
case Token.GETPROP:
if (parent != null) {
switch (parent.getType()) {
case Token.ASSIGN:
if (parent.getFirstChild() == n) {
isSet=true;
type=getValueType(n.getNext());
isPropAssign=true;
}
break;
case Token.GETPROP:
return;
}
}
name=n.getQualifiedName();
if (name == null) return;
break;
default :
return;
}
Scope scope=t.getScope();
if (!isGlobalNameReference(name,scope)) {
return;
}
if (isSet) {
if (isGlobalScope(scope)) {
handleSetFromGlobal(t,n,parent,name,isPropAssign,type);
}
 else {
handleSetFromLocal(t,n,parent,name);
}
}
 else {
handleGet(t,n,parent,name);
}
}
