{
  for (int i=0; i < typeChain.size(); i++) {
    for (int j=0; j < typeChain.size(); j++) {
      JSType typeI=typeChain.get(i);
      JSType typeJ=typeChain.get(j);
      JSType namedTypeI=getNamedWrapper("TypeI",typeI);
      JSType namedTypeJ=getNamedWrapper("TypeJ",typeJ);
      JSType proxyTypeI=new ProxyObjectType(registry,typeI);
      JSType proxyTypeJ=new ProxyObjectType(registry,typeJ);
      if (i == j) {
        assertTrue(typeI + " should equal itself",typeI.isEquivalentTo(typeI));
        assertTrue("Named " + typeI + " should equal itself",namedTypeI.isEquivalentTo(namedTypeI));
        assertTrue("Proxy " + typeI + " should equal itself",proxyTypeI.isEquivalentTo(proxyTypeI));
      }
 else {
        assertFalse(typeI + " should not equal " + typeJ,typeI.isEquivalentTo(typeJ));
        assertFalse("Named " + typeI + " should not equal "+ typeJ,namedTypeI.isEquivalentTo(namedTypeJ));
        assertFalse("Proxy " + typeI + " should not equal "+ typeJ,proxyTypeI.isEquivalentTo(proxyTypeJ));
      }
      if (checkSubtyping) {
        if (i <= j) {
          assertTrue(typeJ + " should be a subtype of " + typeI,typeJ.isSubtype(typeI));
          assertTrue("Named " + typeJ + " should be a subtype of Named "+ typeI,namedTypeJ.isSubtype(namedTypeI));
        }
 else {
          assertFalse(typeJ + " should not be a subtype of " + typeI,typeJ.isSubtype(typeI));
          assertFalse("Named " + typeJ + " should not be a subtype of Named "+ typeI,namedTypeJ.isSubtype(namedTypeI));
        }
        JSType expectedSupremum=i < j ? typeI : typeJ;
        JSType expectedInfimum=i > j ? typeI : typeJ;
        assertTypeEquals(expectedSupremum + " should be the least supertype of " + typeI+ " and "+ typeJ,expectedSupremum,typeI.getLeastSupertype(typeJ));
        assertTypeEquals(expectedInfimum + " should be the greatest subtype of " + typeI+ " and "+ typeJ,expectedInfimum,typeI.getGreatestSubtype(typeJ));
      }
    }
  }
}
