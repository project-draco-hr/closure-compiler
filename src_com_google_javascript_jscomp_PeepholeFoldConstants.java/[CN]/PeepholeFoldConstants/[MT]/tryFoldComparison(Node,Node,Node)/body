{
  boolean leftLiteral=NodeUtil.isLiteralValue(left,true);
  boolean rightLiteral=NodeUtil.isLiteralValue(right,true);
  if (!leftLiteral || !rightLiteral) {
    if (n.getType() != Token.GT && n.getType() != Token.LT) {
      return n;
    }
  }
  int op=n.getType();
  boolean result;
  boolean undefinedRight=NodeUtil.isUndefined(right) && rightLiteral;
  boolean nullRight=right.isNull();
  int lhType=getNormalizedNodeType(left);
  int rhType=getNormalizedNodeType(right);
switch (lhType) {
case Token.VOID:
    if (!leftLiteral) {
      return n;
    }
 else     if (!rightLiteral) {
      return n;
    }
 else {
      result=compareToUndefined(right,op);
    }
  break;
case Token.NULL:
if (rightLiteral && isEqualityOp(op)) {
  result=compareToNull(right,op);
  break;
}
case Token.TRUE:
case Token.FALSE:
if (undefinedRight) {
result=compareToUndefined(left,op);
break;
}
if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) {
return n;
}
switch (op) {
case Token.SHEQ:
case Token.EQ:
result=lhType == rhType;
break;
case Token.SHNE:
case Token.NE:
result=lhType != rhType;
break;
case Token.GE:
case Token.LE:
case Token.GT:
case Token.LT:
Boolean compareResult=compareAsNumbers(op,left,right);
if (compareResult != null) {
result=compareResult;
}
 else {
return n;
}
break;
default :
return n;
}
break;
case Token.THIS:
if (!right.isThis()) {
return n;
}
switch (op) {
case Token.SHEQ:
case Token.EQ:
result=true;
break;
case Token.SHNE:
case Token.NE:
result=false;
break;
default :
return n;
}
break;
case Token.STRING:
if (undefinedRight) {
result=compareToUndefined(left,op);
break;
}
if (nullRight && isEqualityOp(op)) {
result=compareToNull(left,op);
break;
}
if (Token.STRING != right.getType()) {
return n;
}
TernaryValue ternary=TernaryValue.UNKNOWN;
switch (op) {
case Token.SHEQ:
case Token.EQ:
ternary=areStringsEqual(left.getString(),right.getString());
break;
case Token.SHNE:
case Token.NE:
ternary=areStringsEqual(left.getString(),right.getString()).not();
break;
}
if (ternary == TernaryValue.UNKNOWN) {
return n;
}
result=ternary.toBoolean(true);
break;
case Token.NUMBER:
if (undefinedRight) {
result=compareToUndefined(left,op);
break;
}
if (nullRight && isEqualityOp(op)) {
result=compareToNull(left,op);
break;
}
if (Token.NUMBER != right.getType()) {
return n;
}
Boolean compareResult=compareAsNumbers(op,left,right);
if (compareResult != null) {
result=compareResult;
}
 else {
return null;
}
break;
case Token.NAME:
if (leftLiteral && undefinedRight) {
result=compareToUndefined(left,op);
break;
}
if (rightLiteral) {
boolean undefinedLeft=(left.getString().equals("undefined"));
if (undefinedLeft) {
result=compareToUndefined(right,op);
break;
}
if (leftLiteral && nullRight && isEqualityOp(op)) {
result=compareToNull(left,op);
break;
}
}
if (Token.NAME != right.getType()) {
return n;
}
String ln=left.getString();
String rn=right.getString();
if (!ln.equals(rn)) {
return n;
}
switch (op) {
case Token.LT:
case Token.GT:
result=false;
break;
default :
return n;
}
break;
case Token.NEG:
if (leftLiteral) {
if (undefinedRight) {
result=compareToUndefined(left,op);
break;
}
if (nullRight && isEqualityOp(op)) {
result=compareToNull(left,op);
break;
}
}
return n;
case Token.ARRAYLIT:
case Token.OBJECTLIT:
case Token.REGEXP:
case Token.FUNCTION:
if (leftLiteral) {
if (undefinedRight) {
result=compareToUndefined(left,op);
break;
}
if (nullRight && isEqualityOp(op)) {
result=compareToNull(left,op);
break;
}
}
return n;
default :
return n;
}
Node newNode=new Node(result ? Token.TRUE : Token.FALSE);
n.getParent().replaceChild(n,newNode);
reportCodeChange();
return newNode;
}
