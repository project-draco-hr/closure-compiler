{
  Node left=subtree.getFirstChild();
  if (left == null) {
    return subtree;
  }
  Node right=left.getNext();
  if (right == null) {
    return subtree;
  }
switch (subtree.getType()) {
case Token.GETPROP:
    return tryFoldGetProp(subtree,left,right);
case Token.GETELEM:
  return tryFoldGetElem(subtree,left,right);
case Token.INSTANCEOF:
return tryFoldInstanceof(subtree,left,right);
case Token.AND:
case Token.OR:
return tryFoldAndOr(subtree,left,right);
case Token.LSH:
case Token.RSH:
case Token.URSH:
return tryFoldShift(subtree,left,right);
case Token.ASSIGN:
return tryFoldAssign(subtree,left,right);
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_ADD:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
return tryUnfoldAssignOp(subtree,left,right);
case Token.ADD:
return tryFoldAdd(subtree,left,right);
case Token.SUB:
case Token.DIV:
case Token.MOD:
return tryFoldArithmeticOp(subtree,left,right);
case Token.MUL:
case Token.BITAND:
case Token.BITOR:
case Token.BITXOR:
Node result=tryFoldArithmeticOp(subtree,left,right);
if (result != subtree) {
return result;
}
return tryFoldLeftChildOp(subtree,left,right);
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:
return tryFoldComparison(subtree,left,right);
default :
return subtree;
}
}
