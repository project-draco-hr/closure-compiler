{
  Preconditions.checkArgument(NodeUtil.isGet(n));
  if (left.getType() != Token.OBJECTLIT || right.getType() != Token.STRING) {
    return n;
  }
  if (isAssignmentTarget(n)) {
    return n;
  }
  Node key=null;
  Node value=null;
  for (Node c=left.getFirstChild(); c != null; c=c.getNext()) {
    if (c.getString().equals(right.getString())) {
switch (c.getType()) {
case Token.SETTER_DEF:
        continue;
case Token.GETTER_DEF:
case Token.STRING:
      if (value != null && mayHaveSideEffects(value)) {
        return n;
      }
    key=c;
  value=key.getFirstChild();
break;
default :
throw new IllegalStateException();
}
}
 else if (mayHaveSideEffects(c.getFirstChild())) {
return n;
}
}
if (value == null) {
return n;
}
if (value.isFunction() && NodeUtil.referencesThis(value)) {
return n;
}
Node replacement=value.detachFromParent();
if (key.isGetterDef()) {
replacement=new Node(Token.CALL,replacement);
replacement.putBooleanProp(Node.FREE_CALL,true);
}
n.getParent().replaceChild(n,replacement);
reportCodeChange();
return n;
}
