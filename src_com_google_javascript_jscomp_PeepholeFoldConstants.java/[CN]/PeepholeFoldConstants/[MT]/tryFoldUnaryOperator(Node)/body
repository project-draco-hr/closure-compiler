{
  Preconditions.checkState(n.hasOneChild());
  Node left=n.getFirstChild();
  Node parent=n.getParent();
  if (left == null) {
    return n;
  }
  TernaryValue leftVal=NodeUtil.getPureBooleanValue(left);
  if (leftVal == TernaryValue.UNKNOWN) {
    return n;
  }
switch (n.getType()) {
case Token.NOT:
    if (late && left.isNumber()) {
      double numValue=left.getDouble();
      if (numValue == 0 || numValue == 1) {
        return n;
      }
    }
  int result=leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE;
Node replacementNode=new Node(result);
parent.replaceChild(n,replacementNode);
reportCodeChange();
return replacementNode;
case Token.POS:
if (NodeUtil.isNumericResult(left)) {
parent.replaceChild(n,left.detachFromParent());
reportCodeChange();
return left;
}
return n;
case Token.NEG:
try {
if (left.isName()) {
if (left.getString().equals("Infinity")) {
return n;
}
 else if (left.getString().equals("NaN")) {
n.removeChild(left);
parent.replaceChild(n,left);
reportCodeChange();
return left;
}
}
double negNum=-left.getDouble();
Node negNumNode=Node.newNumber(negNum);
parent.replaceChild(n,negNumNode);
reportCodeChange();
return negNumNode;
}
 catch (UnsupportedOperationException ex) {
error(NEGATING_A_NON_NUMBER_ERROR,left);
return n;
}
case Token.BITNOT:
try {
double val=left.getDouble();
if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
int intVal=(int)val;
if (intVal == val) {
Node notIntValNode=Node.newNumber(~intVal);
parent.replaceChild(n,notIntValNode);
reportCodeChange();
return notIntValNode;
}
 else {
error(FRACTIONAL_BITWISE_OPERAND,left);
return n;
}
}
 else {
error(BITWISE_OPERAND_OUT_OF_RANGE,left);
return n;
}
}
 catch (UnsupportedOperationException ex) {
error(NEGATING_A_NON_NUMBER_ERROR,left);
return n;
}
default :
return n;
}
}
