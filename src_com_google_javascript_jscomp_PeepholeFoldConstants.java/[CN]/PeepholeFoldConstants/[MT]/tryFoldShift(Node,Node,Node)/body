{
  if (left.isNumber() && right.isNumber()) {
    double result;
    double lval=left.getDouble();
    double rval=right.getDouble();
    if (lval < Integer.MIN_VALUE) {
      report(BITWISE_OPERAND_OUT_OF_RANGE,left);
      return n;
    }
    if (!(rval >= 0 && rval < 32)) {
      report(SHIFT_AMOUNT_OUT_OF_BOUNDS,n);
      return n;
    }
    int rvalInt=(int)rval;
    if (rvalInt != rval) {
      report(FRACTIONAL_BITWISE_OPERAND,right);
      return n;
    }
switch (n.getToken()) {
case LSH:
case RSH:
      if (lval > Integer.MAX_VALUE) {
        report(BITWISE_OPERAND_OUT_OF_RANGE,left);
        return n;
      }
    int lvalInt=(int)lval;
  if (lvalInt != lval) {
    report(FRACTIONAL_BITWISE_OPERAND,left);
    return n;
  }
if (n.getToken() == Token.LSH) {
  result=lvalInt << rvalInt;
}
 else {
  result=lvalInt >> rvalInt;
}
break;
case URSH:
long maxUint32=0xffffffffL;
if (lval > maxUint32) {
report(BITWISE_OPERAND_OUT_OF_RANGE,left);
return n;
}
long lvalLong=(long)lval;
if (lvalLong != lval) {
report(FRACTIONAL_BITWISE_OPERAND,left);
return n;
}
result=(lvalLong & maxUint32) >>> rvalInt;
break;
default :
throw new AssertionError("Unknown shift operator: " + n.getToken());
}
Node newNumber=IR.number(result);
n.getParent().replaceChild(n,newNumber);
reportCodeChange();
return newNumber;
}
return n;
}
