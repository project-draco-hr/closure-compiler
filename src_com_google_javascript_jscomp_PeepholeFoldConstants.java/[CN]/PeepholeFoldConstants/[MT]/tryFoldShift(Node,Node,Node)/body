{
  if (left.isNumber() && right.isNumber()) {
    double result;
    double lval=left.getDouble();
    double rval=right.getDouble();
    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
      report(BITWISE_OPERAND_OUT_OF_RANGE,left);
      return n;
    }
    if (!(rval >= 0 && rval < 32)) {
      report(SHIFT_AMOUNT_OUT_OF_BOUNDS,right);
      return n;
    }
    int lvalInt=(int)lval;
    if (lvalInt != lval) {
      report(FRACTIONAL_BITWISE_OPERAND,left);
      return n;
    }
    int rvalInt=(int)rval;
    if (rvalInt != rval) {
      report(FRACTIONAL_BITWISE_OPERAND,right);
      return n;
    }
switch (n.getType()) {
case Token.LSH:
      result=lvalInt << rvalInt;
    break;
case Token.RSH:
  result=lvalInt >> rvalInt;
break;
case Token.URSH:
long lvalLong=lvalInt & 0xffffffffL;
result=lvalLong >>> rvalInt;
break;
default :
throw new AssertionError("Unknown shift operator: " + Token.name(n.getType()));
}
Node newNumber=IR.number(result);
n.getParent().replaceChild(n,newNumber);
reportCodeChange();
return newNumber;
}
return n;
}
