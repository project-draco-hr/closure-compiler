{
  if (opType == Token.ADD && (left.getType() != Token.NUMBER || right.getType() != Token.NUMBER)) {
    return null;
  }
  double result;
  Double lValObj=NodeUtil.getNumberValue(left);
  if (lValObj == null) {
    return null;
  }
  Double rValObj=NodeUtil.getNumberValue(right);
  if (rValObj == null) {
    return null;
  }
  double lval=lValObj;
  double rval=rValObj;
switch (opType) {
case Token.BITAND:
    if (!areValidInts(lval,rval)) {
      return null;
    }
  result=(int)lval & (int)rval;
break;
case Token.BITOR:
if (!areValidInts(lval,rval)) {
return null;
}
result=(int)lval | (int)rval;
break;
case Token.BITXOR:
if (!areValidInts(lval,rval)) {
return null;
}
result=(int)lval ^ (int)rval;
break;
case Token.ADD:
result=lval + rval;
break;
case Token.SUB:
result=lval - rval;
break;
case Token.MUL:
result=lval * rval;
break;
case Token.MOD:
if (rval == 0) {
error(DIVIDE_BY_0_ERROR,right);
return null;
}
result=lval % rval;
break;
case Token.DIV:
if (rval == 0) {
error(DIVIDE_BY_0_ERROR,right);
return null;
}
result=lval / rval;
break;
default :
throw new Error("Unexpected arithmetic operator");
}
if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && Math.abs(result) <= MAX_FOLD_NUMBER) {
Node newNumber=Node.newNumber(result);
return newNumber;
}
 else if (Double.isNaN(result)) {
return Node.newString(Token.NAME,"NaN");
}
 else if (result == Double.POSITIVE_INFINITY) {
return Node.newString(Token.NAME,"Infinity");
}
 else if (result == Double.NEGATIVE_INFINITY) {
return new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
}
return null;
}
