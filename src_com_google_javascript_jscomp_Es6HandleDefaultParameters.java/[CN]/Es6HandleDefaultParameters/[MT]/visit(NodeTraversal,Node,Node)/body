{
  if (!n.isFunction() || !n.getLastChild().isBlock()) {
    return;
  }
  Node paramList=n.getChildAtIndex(1);
  CollectReferences collector=new CollectReferences();
  for (  Node child : paramList.children()) {
    if (child.isName() && child.hasChildren()) {
      NodeTraversal.traverse(compiler,child.getFirstChild(),collector);
    }
  }
  Node block=paramList.getNext();
  Es6SyntacticScopeCreator creator=new Es6SyntacticScopeCreator(compiler);
  Scope fScope=creator.createScope(n,t.getScope());
  Scope fBlockScope=creator.createScope(block,fScope);
  Map<String,String> currFuncRenameMap=new HashMap<>();
  for (Iterator<Var> it=fBlockScope.getVars(); it.hasNext(); ) {
    Var var=it.next();
    String oldName=var.getName();
    if (collector.currFuncReferences.contains(oldName) && !currFuncRenameMap.containsKey(oldName)) {
      currFuncRenameMap.put(oldName,unique.generate(oldName));
    }
  }
  new NodeTraversal(compiler,new RenameReferences(fBlockScope,currFuncRenameMap)).traverseInnerNode(block,block.getParent(),fScope);
}
