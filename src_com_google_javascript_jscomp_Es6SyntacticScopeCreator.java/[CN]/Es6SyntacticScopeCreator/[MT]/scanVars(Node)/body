{
switch (n.getType()) {
case Token.VAR:
    for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
      declareLHS(scope.getClosestHoistScope(),child);
    }
  return;
case Token.LET:
case Token.CONST:
if (!isNodeAtCurrentLexicalScope(n)) {
  return;
}
for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
declareLHS(scope,child);
}
return;
case Token.FUNCTION:
if (NodeUtil.isFunctionExpression(n) || !isNodeAtCurrentLexicalScope(n)) {
return;
}
String fnName=n.getFirstChild().getString();
if (fnName.isEmpty()) {
return;
}
declareVar(n.getFirstChild());
return;
case Token.CLASS:
if (NodeUtil.isClassExpression(n) || !isNodeAtCurrentLexicalScope(n)) {
return;
}
String className=n.getFirstChild().getString();
if (className.isEmpty()) {
return;
}
declareVar(n.getFirstChild());
return;
case Token.CATCH:
Preconditions.checkState(n.getChildCount() == 2);
final Node exception=n.getFirstChild();
final Node block=exception.getNext();
if (isNodeAtCurrentLexicalScope(n)) {
declareLHS(scope,exception);
}
scanVars(block);
return;
case Token.SCRIPT:
inputId=n.getInputId();
Preconditions.checkNotNull(inputId);
break;
}
if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {
for (Node child=n.getFirstChild(); child != null; ) {
Node next=child.getNext();
scanVars(child);
child=next;
}
}
}
