{
  if (isClosureSpecificCall(expr)) {
    return analyzeClosureCallFwd(expr,inEnv,specializedType);
  }
  Node callee=expr.getFirstChild();
  if (isFunctionBind(callee,inEnv,true)) {
    return analyzeFunctionBindFwd(expr,inEnv);
  }
  AssertionFunctionSpec assertionFunctionSpec=assertionFunctionsMap.get(callee.getQualifiedName());
  if (assertionFunctionSpec != null) {
    return analyzeAssertionCall(expr,inEnv,assertionFunctionSpec);
  }
  EnvTypePair calleePair=analyzeExprFwd(callee,inEnv,commonTypes.topFunction());
  JSType calleeType=calleePair.type;
  if (!calleeType.isSubtypeOf(commonTypes.topFunction())) {
    warnings.add(JSError.make(expr,TypeCheck.NOT_CALLABLE,calleeType.toString()));
  }
  FunctionType funType=calleeType.getFunType();
  if (funType == null || funType.isTopFunction() || funType.isQmarkFunction()) {
    return analyzeCallNodeArgsFwdWhenError(expr,inEnv);
  }
 else   if (funType.isLoose()) {
    return analyzeLooseCallNodeFwd(expr,inEnv,requiredType);
  }
 else   if (expr.isCall() && funType.isConstructor() && funType.getReturnType().isUnknown()) {
    warnings.add(JSError.make(expr,TypeCheck.CONSTRUCTOR_NOT_CALLABLE,funType.toString()));
    return analyzeCallNodeArgsFwdWhenError(expr,inEnv);
  }
 else   if (expr.isNew() && !funType.isConstructor()) {
    warnings.add(JSError.make(expr,NOT_A_CONSTRUCTOR,funType.toString()));
    return analyzeCallNodeArgsFwdWhenError(expr,inEnv);
  }
  int maxArity=funType.getMaxArity();
  int minArity=funType.getMinArity();
  int numArgs=expr.getChildCount() - 1;
  if (numArgs < minArity || numArgs > maxArity) {
    warnings.add(JSError.make(expr,TypeCheck.WRONG_ARGUMENT_COUNT,getReadableCalleeName(callee),Integer.toString(numArgs),Integer.toString(minArity)," and at most " + maxArity));
    return analyzeCallNodeArgsFwdWhenError(expr,inEnv);
  }
  FunctionType origFunType=funType;
  if (funType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationFwd(expr,expr.getChildAtIndex(1),funType,inEnv);
    funType=funType.instantiateGenerics(typeMap);
    println("Instantiated function type: " + funType);
  }
  List<JSType> argTypes=new ArrayList<>();
  TypeEnv tmpEnv=analyzeCallNodeArgumentsFwd(expr,expr.getChildAtIndex(1),funType,argTypes,inEnv);
  if (callee.isName()) {
    String calleeName=callee.getQualifiedName();
    if (currentScope.isKnownFunction(calleeName) && !currentScope.isExternalFunction(calleeName)) {
      if (currentScope.isLocalFunDef(calleeName)) {
        collectTypesForFreeVarsFwd(callee,tmpEnv);
      }
 else       if (!origFunType.isGeneric()) {
        JSType expectedRetType=requiredType;
        println("Updating deferred check with ret: ",expectedRetType," and args: ",argTypes);
        DeferredCheck dc;
        if (expr.isCall()) {
          dc=deferredChecks.get(expr);
          if (dc != null) {
            dc.updateReturn(expectedRetType);
          }
 else {
            Preconditions.checkState(!currentScope.hasUndeclaredFormalsOrOuters(),"No deferred check created in backward direction for %s",expr);
          }
        }
 else {
          dc=new DeferredCheck(expr,null,currentScope,currentScope.getScope(calleeName));
          deferredChecks.put(expr,dc);
        }
        if (dc != null) {
          dc.updateArgTypes(argTypes);
        }
      }
    }
  }
  JSType retType=expr.isNew() ? funType.getThisType() : funType.getReturnType();
  return new EnvTypePair(tmpEnv,retType);
}
