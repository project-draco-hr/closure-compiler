{
  Preconditions.checkArgument(requiredType != null,"Required type null at: " + expr);
  Preconditions.checkArgument(!requiredType.isBottom());
switch (expr.getType()) {
case Token.EMPTY:
    return new EnvTypePair(outEnv,JSType.UNKNOWN);
case Token.FUNCTION:
{
    String fnName=symbolTable.getFunInternalName(expr);
    return new EnvTypePair(outEnv,envGetType(outEnv,fnName));
  }
case Token.FALSE:
case Token.NULL:
case Token.NUMBER:
case Token.STRING:
case Token.TRUE:
return new EnvTypePair(outEnv,scalarValueToType(expr.getType()));
case Token.OBJECTLIT:
return analyzeObjLitBwd(expr,outEnv,requiredType);
case Token.THIS:
{
if (!currentScope.hasThis()) {
return new EnvTypePair(outEnv,JSType.UNKNOWN);
}
JSType thisType=currentScope.getDeclaredTypeOf("this");
return new EnvTypePair(outEnv,thisType);
}
case Token.NAME:
return analyzeNameBwd(expr,outEnv,requiredType);
case Token.INC:
case Token.DEC:
case Token.BITNOT:
case Token.POS:
case Token.NEG:
return analyzeExprBwd(expr.getFirstChild(),outEnv,JSType.NUMBER);
case Token.TYPEOF:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.STRING;
return pair;
}
case Token.INSTANCEOF:
{
TypeEnv env=analyzeExprBwd(expr.getLastChild(),outEnv,JSType.topFunction()).env;
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),env);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.BITOR:
case Token.BITAND:
case Token.BITXOR:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
return analyzeBinaryNumericOpBwd(expr,outEnv);
case Token.ADD:
return analyzeAddBwd(expr,outEnv);
case Token.OR:
case Token.AND:
return analyzeLogicalOpBwd(expr,outEnv);
case Token.SHEQ:
case Token.SHNE:
case Token.EQ:
case Token.NE:
return analyzeEqNeBwd(expr,outEnv);
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
return analyzeLtGtBwd(expr,outEnv);
case Token.ASSIGN:
return analyzeAssignBwd(expr,outEnv,requiredType);
case Token.ASSIGN_ADD:
return analyzeAssignAddBwd(expr,outEnv,requiredType);
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
return analyzeAssignNumericOpBwd(expr,outEnv);
case Token.GETPROP:
{
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()) || !NodeUtil.isLValue(expr));
return analyzePropAccessBwd(expr.getFirstChild(),expr.getLastChild().getString(),outEnv,requiredType);
}
case Token.HOOK:
return analyzeHookBwd(expr,outEnv,requiredType);
case Token.CALL:
case Token.NEW:
return analyzeCallNewBwd(expr,outEnv,requiredType);
case Token.COMMA:
{
EnvTypePair pair=analyzeExprBwd(expr.getLastChild(),outEnv,requiredType);
pair.env=analyzeExprBwd(expr.getFirstChild(),pair.env).env;
return pair;
}
case Token.NOT:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=pair.type.negate();
return pair;
}
case Token.GETELEM:
return analyzeGetElemBwd(expr,outEnv,requiredType);
case Token.VOID:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.UNDEFINED;
return pair;
}
case Token.IN:
return analyzeInBwd(expr,outEnv);
case Token.DELPROP:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.VAR:
{
Node vdecl=expr.getFirstChild();
String name=vdecl.getString();
Preconditions.checkState(!vdecl.hasChildren());
return new EnvTypePair(envPutType(outEnv,name,JSType.UNKNOWN),JSType.UNKNOWN);
}
case Token.REGEXP:
return new EnvTypePair(outEnv,regexpType);
case Token.ARRAYLIT:
return analyzeArrayLitBwd(expr,outEnv);
case Token.CAST:
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=symbolTable.getCastType(expr);
return pair;
default :
throw new RuntimeException("BWD: Unhandled expression type: " + Token.name(expr.getType()) + " with parent: "+ expr.getParent());
}
}
