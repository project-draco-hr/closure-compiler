{
  Preconditions.checkArgument(requiredType != null);
  Preconditions.checkArgument(!requiredType.isBottom());
  int exprKind=expr.getType();
switch (exprKind) {
case Token.EMPTY:
    return new EnvTypePair(outEnv,JSType.UNKNOWN);
case Token.FUNCTION:
{
    String fnName=symbolTable.getFunInternalName(expr);
    return new EnvTypePair(outEnv,envGetType(outEnv,fnName));
  }
case Token.FALSE:
case Token.NULL:
case Token.NUMBER:
case Token.STRING:
case Token.TRUE:
return new EnvTypePair(outEnv,scalarValueToType(exprKind));
case Token.OBJECTLIT:
{
TypeEnv env=outEnv;
JSType result=pickReqObjType(expr);
for (Node prop=expr.getLastChild(); prop != null; prop=expr.getChildBefore(prop)) {
  QualifiedName pname=new QualifiedName(NodeUtil.getObjectLitKeyName(prop));
  JSType jsdocType=symbolTable.getPropDeclaredType(prop);
  JSType reqPtype;
  if (jsdocType != null) {
    reqPtype=jsdocType;
  }
 else   if (requiredType.mayHaveProp(pname)) {
    reqPtype=requiredType.getProp(pname);
  }
 else {
    reqPtype=JSType.UNKNOWN;
  }
  EnvTypePair pair=analyzeExprBwd(prop.getFirstChild(),env,reqPtype);
  result=result.withProperty(pname,pair.type);
  env=pair.env;
}
return new EnvTypePair(env,result);
}
case Token.THIS:
{
if (!currentScope.hasThis()) {
return new EnvTypePair(outEnv,JSType.UNKNOWN);
}
JSType thisType=currentScope.getDeclaredTypeOf("this");
return new EnvTypePair(outEnv,thisType);
}
case Token.NAME:
{
if (expr.matchesQualifiedName("undefined")) {
return new EnvTypePair(outEnv,JSType.UNDEFINED);
}
String varName=expr.getQualifiedName();
JSType inferredType=envGetType(outEnv,varName);
if (inferredType == null) {
inferredType=JSType.UNKNOWN;
}
JSType preciseType=inferredType.specialize(requiredType);
if (currentScope.isUndeclaredFormal(varName) && requiredType.hasNonScalar()) {
preciseType=preciseType.withLoose();
}
if (!preciseType.isInhabitable()) {
JSType declType=currentScope.getDeclaredTypeOf(varName);
preciseType=declType == null ? requiredType : declType;
}
return EnvTypePair.addBinding(outEnv,varName,preciseType);
}
case Token.INC:
case Token.DEC:
case Token.BITNOT:
case Token.POS:
case Token.NEG:
return analyzeExprBwd(expr.getFirstChild(),outEnv,JSType.NUMBER);
case Token.TYPEOF:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.STRING;
return pair;
}
case Token.INSTANCEOF:
{
TypeEnv env=analyzeExprBwd(expr.getLastChild(),outEnv,JSType.topFunction()).env;
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),env);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.BITOR:
case Token.BITAND:
case Token.BITXOR:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
TypeEnv rhsEnv=analyzeExprBwd(rhs,outEnv,JSType.NUMBER).env;
EnvTypePair pair=analyzeExprBwd(lhs,rhsEnv,JSType.NUMBER);
pair.type=JSType.NUMBER;
return pair;
}
case Token.ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair rhsPair=analyzeExprBwd(rhs,outEnv,JSType.NUM_OR_STR);
EnvTypePair lhsPair=analyzeExprBwd(lhs,rhsPair.env,JSType.NUM_OR_STR);
lhsPair.type=JSType.plus(lhsPair.type,rhsPair.type);
return lhsPair;
}
case Token.OR:
case Token.AND:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair rhsPair=analyzeExprBwd(rhs,outEnv);
EnvTypePair lhsPair=analyzeExprBwd(lhs,rhsPair.env);
lhsPair.type=JSType.join(rhsPair.type,lhsPair.type);
return lhsPair;
}
case Token.SHEQ:
case Token.SHNE:
case Token.EQ:
case Token.NE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
TypeEnv rhsEnv=analyzeExprBwd(rhs,outEnv).env;
EnvTypePair pair=analyzeExprBwd(lhs,rhsEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair rhsPair=analyzeExprBwd(rhs,outEnv);
EnvTypePair lhsPair=analyzeExprBwd(lhs,rhsPair.env);
JSType meetType=JSType.meet(lhsPair.type,rhsPair.type);
if (meetType.isBottom()) {
lhsPair.type=JSType.BOOLEAN;
return lhsPair;
}
rhsPair=analyzeExprBwd(rhs,outEnv,meetType);
lhsPair=analyzeExprBwd(lhs,rhsPair.env,meetType);
lhsPair.type=JSType.BOOLEAN;
return lhsPair;
}
case Token.ASSIGN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
LValueResultBwd lvalue=analyzeLValueBwd(lhs,outEnv,requiredType,true);
TypeEnv slicedEnv=lvalue.env;
JSType rhsReqType=specializeWithCorrection(lvalue.type,requiredType);
EnvTypePair pair=analyzeExprBwd(rhs,slicedEnv,rhsReqType);
pair.env=analyzeLValueBwd(lhs,pair.env,requiredType,true).env;
return pair;
}
case Token.ASSIGN_ADD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
JSType lhsReqType=specializeWithCorrection(requiredType,JSType.NUM_OR_STR);
LValueResultBwd lvalue=analyzeLValueBwd(lhs,outEnv,lhsReqType,false);
JSType rhsReqType=lvalue.type.equals(JSType.NUMBER) ? JSType.NUMBER : JSType.NUM_OR_STR;
EnvTypePair pair=analyzeExprBwd(rhs,outEnv,rhsReqType);
pair.env=analyzeLValueBwd(lhs,pair.env,lhsReqType,false).env;
return pair;
}
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair pair=analyzeExprBwd(rhs,outEnv,JSType.NUMBER);
LValueResultBwd lvalue=analyzeLValueBwd(lhs,pair.env,JSType.NUMBER,false);
return new EnvTypePair(lvalue.env,JSType.NUMBER);
}
case Token.GETPROP:
{
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()) || !NodeUtil.isLValue(expr));
return analyzePropAccessBwd(expr.getFirstChild(),expr.getLastChild().getString(),outEnv,requiredType);
}
case Token.HOOK:
{
Node cond=expr.getFirstChild();
Node thenBranch=cond.getNext();
Node elseBranch=thenBranch.getNext();
outEnv=outEnv.split();
EnvTypePair thenPair=analyzeExprBwd(thenBranch,outEnv,requiredType);
EnvTypePair elsePair=analyzeExprBwd(elseBranch,outEnv,requiredType);
return analyzeExprBwd(cond,TypeEnv.join(thenPair.env,elsePair.env));
}
case Token.CALL:
case Token.NEW:
{
Node callee=expr.getFirstChild();
JSType calleeTypeGeneral=analyzeExprBwd(callee,outEnv,JSType.topFunction()).type;
FunctionType funType=calleeTypeGeneral.getFunType();
if (funType == null) {
return analyzeCallNodeArgumentsBwd(expr,outEnv);
}
 else if (funType.isLoose()) {
return analyzeLooseCallNodeBwd(expr,outEnv,requiredType);
}
 else if (expr.isCall() && funType.isConstructor() || expr.isNew() && !funType.isConstructor()) {
return analyzeCallNodeArgumentsBwd(expr,outEnv);
}
 else if (funType.isTopFunction()) {
return analyzeCallNodeArgumentsBwd(expr,outEnv);
}
if (callee.isName() && !funType.isGeneric() && expr.isCall()) {
createDeferredCheckBwd(expr,requiredType);
}
int numArgs=expr.getChildCount() - 1;
if (numArgs < funType.getMinArity() || numArgs > funType.getMaxArity()) {
return analyzeCallNodeArgumentsBwd(expr,outEnv);
}
if (funType.isGeneric()) {
Map<String,JSType> typeMap=calcTypeInstantiationBwd(expr,funType,outEnv);
funType=funType.instantiateGenerics(typeMap);
}
TypeEnv tmpEnv=outEnv;
for (int i=expr.getChildCount() - 2; i >= 0; i--) {
JSType formalType=funType.getFormalType(i);
if (formalType.isBottom()) {
formalType=JSType.UNKNOWN;
}
Node arg=expr.getChildAtIndex(i + 1);
tmpEnv=analyzeExprBwd(arg,tmpEnv,formalType).env;
}
if (callee.isName() && currentScope.isLocalFunDef(callee.getString())) {
tmpEnv=collectTypesForFreeVarsBwd(callee,tmpEnv);
}
return new EnvTypePair(tmpEnv,funType.getReturnType());
}
case Token.COMMA:
{
EnvTypePair pair=analyzeExprBwd(expr.getLastChild(),outEnv,requiredType);
pair.env=analyzeExprBwd(expr.getFirstChild(),pair.env).env;
return pair;
}
case Token.NOT:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=pair.type.negate();
return pair;
}
case Token.GETELEM:
{
Node receiver=expr.getFirstChild();
Node index=expr.getLastChild();
JSType reqObjType=pickReqObjType(expr);
EnvTypePair pair=analyzeExprBwd(receiver,outEnv,reqObjType);
if (isArrayType(pair.type)) {
pair=analyzeExprBwd(index,pair.env,JSType.NUMBER);
pair.type=requiredType;
return pair;
}
if (index.isString()) {
return analyzePropAccessBwd(receiver,index.getString(),outEnv,requiredType);
}
pair=analyzeExprBwd(index,outEnv);
pair=analyzeExprBwd(receiver,pair.env,reqObjType);
pair.type=requiredType;
return pair;
}
case Token.VOID:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.UNDEFINED;
return pair;
}
case Token.IN:
{
Node lhs=expr.getFirstChild();
Node rhs=expr.getLastChild();
EnvTypePair pair=analyzeExprBwd(rhs,outEnv,pickReqObjType(expr));
pair=analyzeExprBwd(lhs,pair.env,JSType.NUM_OR_STR);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.DELPROP:
{
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.VAR:
{
Node vdecl=expr.getFirstChild();
String name=vdecl.getQualifiedName();
Preconditions.checkState(!vdecl.hasChildren());
return new EnvTypePair(envPutType(outEnv,name,JSType.UNKNOWN),JSType.UNKNOWN);
}
case Token.REGEXP:
return new EnvTypePair(outEnv,regexpType);
case Token.ARRAYLIT:
TypeEnv env=outEnv;
for (int i=expr.getChildCount() - 1; i >= 0; i--) {
Node arrayElm=expr.getChildAtIndex(i);
env=analyzeExprBwd(arrayElm,env).env;
}
return new EnvTypePair(env,arrayType);
case Token.CAST:
EnvTypePair pair=analyzeExprBwd(expr.getFirstChild(),outEnv);
pair.type=symbolTable.getCastType(expr);
return pair;
default :
throw new RuntimeException("BWD: Unhandled expression type: " + Token.name(expr.getType()) + " with parent: "+ expr.getParent());
}
}
