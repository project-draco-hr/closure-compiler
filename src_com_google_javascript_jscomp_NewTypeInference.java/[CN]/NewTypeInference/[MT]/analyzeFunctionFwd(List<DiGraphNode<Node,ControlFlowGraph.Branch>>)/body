{
  for (  DiGraphNode<Node,ControlFlowGraph.Branch> dn : workset) {
    Node n=dn.getValue();
    Preconditions.checkState(n != null,"Implicit return should not be in workset.");
    TypeEnv inEnv=getInEnv(n);
    TypeEnv outEnv=null;
    println("\tFWD Statment: ",n);
    println("\t\tinEnv: ",inEnv);
    boolean conditional=false;
switch (n.getType()) {
case Token.BLOCK:
case Token.BREAK:
case Token.CATCH:
case Token.CONTINUE:
case Token.DEFAULT_CASE:
case Token.EMPTY:
case Token.FUNCTION:
case Token.SCRIPT:
case Token.TRY:
      outEnv=inEnv;
    break;
case Token.EXPR_RESULT:
  println("\tsemi ",Token.name(n.getFirstChild().getType()));
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv,TypeConsts.TOP).env;
break;
case Token.RETURN:
{
Node retExp=n.getFirstChild();
JSType declRetType=currentScope.getDeclaredType().getReturnType();
declRetType=declRetType == null ? TypeConsts.UNKNOWN : declRetType;
JSType actualRetType;
if (retExp == null) {
actualRetType=TypeConsts.UNDEFINED;
outEnv=envPutType(inEnv,RETVAL_ID,actualRetType);
}
 else {
EnvTypePair retPair=analyzeExprFwd(retExp,inEnv,declRetType);
actualRetType=retPair.type;
outEnv=envPutType(retPair.env,RETVAL_ID,actualRetType);
}
if (!actualRetType.isSubtypeOf(declRetType)) {
warnings.add(JSError.make(n,RETURN_NONDECLARED_TYPE,declRetType.toString(),actualRetType.toString()));
}
break;
}
case Token.DO:
case Token.IF:
case Token.FOR:
case Token.WHILE:
conditional=true;
analyzeConditionalStmFwd(n,getConditionExpression(n),inEnv);
break;
case Token.CASE:
{
conditional=true;
Node switchedExp=n.getParent().getFirstChild().cloneTree();
Node syntheticSheq=IR.sheq(switchedExp,n.getFirstChild().cloneTree());
analyzeConditionalStmFwd(n,syntheticSheq,inEnv);
break;
}
case Token.VAR:
outEnv=inEnv;
for (Node nameNode=n.getFirstChild(); nameNode != null; nameNode=nameNode.getNext()) {
outEnv=processVarDeclaration(nameNode,outEnv);
}
break;
case Token.SWITCH:
case Token.THROW:
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv).env;
break;
default :
if (NodeUtil.isStatement(n)) {
throw new RuntimeException("Unhandled statement type: " + Token.name(n.getType()));
}
 else {
outEnv=analyzeExprFwd(n,inEnv,TypeConsts.TOP).env;
break;
}
}
if (!conditional) {
println("\t\toutEnv: ",outEnv);
setOutEnv(n,outEnv);
}
}
}
