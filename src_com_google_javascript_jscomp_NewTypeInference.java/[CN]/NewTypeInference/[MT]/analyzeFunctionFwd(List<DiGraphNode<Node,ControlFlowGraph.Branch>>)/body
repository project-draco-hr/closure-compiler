{
  for (  DiGraphNode<Node,ControlFlowGraph.Branch> dn : workset) {
    Node n=dn.getValue();
    Node parent=n.getParent();
    Preconditions.checkState(n != null,"Implicit return should not be in workset.");
    TypeEnv inEnv=getInEnv(dn);
    TypeEnv outEnv=null;
    if (parent.isScript() || (parent.isBlock() && parent.getParent().isFunction())) {
      inEnv=inEnv.clearChangeLog();
    }
    println("\tFWD Statment: ",n);
    println("\t\tinEnv: ",inEnv);
    boolean conditional=false;
switch (n.getType()) {
case Token.BLOCK:
case Token.BREAK:
case Token.CONTINUE:
case Token.DEFAULT_CASE:
case Token.DEBUGGER:
case Token.EMPTY:
case Token.FUNCTION:
case Token.SCRIPT:
case Token.TRY:
      outEnv=inEnv;
    break;
case Token.CATCH:
  String catchVarname=n.getFirstChild().getString();
outEnv=envPutType(inEnv,catchVarname,JSType.UNKNOWN);
break;
case Token.EXPR_RESULT:
println("\tsemi ",Token.name(n.getFirstChild().getType()));
if (n.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
n.removeProp(Node.ANALYZED_DURING_GTI);
outEnv=inEnv;
}
 else {
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv,JSType.UNKNOWN).env;
}
break;
case Token.RETURN:
{
Node retExp=n.getFirstChild();
JSType declRetType=currentScope.getDeclaredFunctionType().getReturnType();
declRetType=declRetType == null ? JSType.UNKNOWN : declRetType;
JSType actualRetType;
if (retExp == null) {
actualRetType=JSType.UNDEFINED;
outEnv=envPutType(inEnv,RETVAL_ID,actualRetType);
}
 else {
EnvTypePair retPair=analyzeExprFwd(retExp,inEnv,declRetType);
actualRetType=retPair.type;
outEnv=envPutType(retPair.env,RETVAL_ID,actualRetType);
}
if (!actualRetType.isSubtypeOf(declRetType)) {
warnings.add(JSError.make(n,RETURN_NONDECLARED_TYPE,declRetType.toString(),actualRetType.toString()));
}
break;
}
case Token.DO:
case Token.IF:
case Token.FOR:
case Token.WHILE:
if (NodeUtil.isForIn(n)) {
Node obj=n.getSecondChild();
EnvTypePair pair=analyzeExprFwd(obj,inEnv,pickReqObjType(n));
pair=mayWarnAboutNullableReferenceAndTighten(n,pair.type,null,inEnv);
JSType objType=pair.type;
if (!objType.isSubtypeOf(JSType.TOP_OBJECT)) {
warnings.add(JSError.make(obj,FORIN_EXPECTS_OBJECT,objType.toString()));
}
 else if (objType.isStruct()) {
warnings.add(JSError.make(obj,IN_USED_WITH_STRUCT));
}
Node lhs=n.getFirstChild();
LValueResultFwd lval=analyzeLValueFwd(lhs,inEnv,JSType.STRING);
if (lval.declType != null && !commonTypes.isStringScalarOrObj(lval.declType)) {
warnings.add(JSError.make(lhs,FORIN_EXPECTS_STRING_KEY,lval.declType.toString()));
outEnv=lval.env;
}
 else {
outEnv=updateLvalueTypeInEnv(lval.env,lhs,lval.ptr,JSType.STRING);
}
break;
}
conditional=true;
analyzeConditionalStmFwd(dn,NodeUtil.getConditionExpression(n),inEnv);
break;
case Token.CASE:
{
conditional=true;
analyzeConditionalStmFwd(dn,n,inEnv);
break;
}
case Token.VAR:
outEnv=inEnv;
if (NodeUtil.isTypedefDecl(n)) {
break;
}
for (Node nameNode=n.getFirstChild(); nameNode != null; nameNode=nameNode.getNext()) {
outEnv=processVarDeclaration(nameNode,outEnv);
}
break;
case Token.SWITCH:
case Token.THROW:
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv).env;
break;
default :
if (NodeUtil.isStatement(n)) {
throw new RuntimeException("Unhandled statement type: " + Token.name(n.getType()));
}
 else {
outEnv=analyzeExprFwd(n,inEnv,JSType.UNKNOWN).env;
break;
}
}
if (!conditional) {
println("\t\toutEnv: ",outEnv);
setOutEnv(dn,outEnv);
}
}
}
