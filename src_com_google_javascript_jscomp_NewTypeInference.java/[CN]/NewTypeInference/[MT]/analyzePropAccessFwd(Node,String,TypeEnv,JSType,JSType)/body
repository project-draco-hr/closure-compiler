{
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType objWithProp=JSType.TOP_OBJECT.withProperty(pname,requiredType);
  JSType recvReqType, recvSpecType, recvType;
  if (specializedType.isTruthy() || specializedType.isFalsy()) {
    recvReqType=JSType.TOP;
    recvSpecType=objWithProp;
  }
 else {
    recvReqType=recvSpecType=objWithProp;
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  recvType=pair.type;
  boolean isNotAnObject=JSType.BOTTOM.equals(JSType.meet(recvType,JSType.TOP_OBJECT));
  boolean mayNotBeAnObject=!recvType.isSubtypeOf(JSType.TOP_OBJECT);
  if (isNotAnObject || (!specializedType.isTruthy() && !specializedType.isFalsy() && mayNotBeAnObject)) {
    warnings.add(JSError.make(receiver,PROPERTY_ACCESS_ON_NONOBJECT,pname,recvType.toString()));
    return new EnvTypePair(pair.env,requiredType);
  }
  JSType resultType=recvType.getProp(pname);
  if (!specializedType.isTruthy() && !specializedType.isFalsy()) {
    if (!recvType.mayHaveProp(pname)) {
      warnings.add(JSError.make(propAccessNode,TypeCheck.INEXISTENT_PROPERTY,pname,recvType.toString()));
      resultType=JSType.UNKNOWN;
    }
 else     if (!recvType.hasProp(pname)) {
      warnings.add(JSError.make(propAccessNode,NewTypeInference.POSSIBLY_INEXISTENT_PROPERTY,pname,recvType.toString()));
    }
  }
  return new EnvTypePair(pair.env,resultType);
}
