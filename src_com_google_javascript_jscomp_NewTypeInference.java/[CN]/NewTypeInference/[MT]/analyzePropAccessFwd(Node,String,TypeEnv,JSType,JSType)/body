{
  QualifiedName propQname=new QualifiedName(pname);
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType objWithProp=JSType.TOP_OBJECT.withProperty(propQname,requiredType);
  JSType recvReqType, recvSpecType, recvType;
  if (specializedType.isTruthy() || specializedType.isFalsy()) {
    recvReqType=JSType.UNKNOWN;
    recvSpecType=objWithProp;
  }
 else {
    recvReqType=recvSpecType=objWithProp;
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  recvType=pair.type;
  boolean isNotAnObject=JSType.BOTTOM.equals(JSType.meet(recvType,JSType.TOP_OBJECT));
  boolean mayNotBeAnObject=!recvType.isSubtypeOf(JSType.TOP_OBJECT);
  if (isNotAnObject || (!specializedType.isTruthy() && !specializedType.isFalsy() && mayNotBeAnObject)) {
    warnings.add(JSError.make(receiver,PROPERTY_ACCESS_ON_NONOBJECT,pname,recvType.toString()));
    return new EnvTypePair(pair.env,requiredType);
  }
  JSType resultType=recvType.getProp(propQname);
  if (!propAccessNode.getParent().isExprResult() && !specializedType.isTruthy() && !specializedType.isFalsy()) {
    if (!recvType.mayHaveProp(propQname)) {
      warnings.add(JSError.make(propAccessNode,TypeCheck.INEXISTENT_PROPERTY,pname,recvType.toString()));
    }
 else     if (!recvType.hasProp(propQname)) {
      warnings.add(JSError.make(propAccessNode,NewTypeInference.POSSIBLY_INEXISTENT_PROPERTY,pname,recvType.toString()));
    }
 else     if (recvType.hasInferredProp(propQname) && !resultType.isSubtypeOf(requiredType) && requiredType.isSubtypeOf(resultType)) {
      LValueResultFwd lvr=analyzeLValueFwd(propAccessNode,inEnv,requiredType);
      TypeEnv updatedEnv=updateLvalueTypeInEnv(lvr.env,propAccessNode,lvr.ptr,requiredType);
      return new EnvTypePair(updatedEnv,requiredType);
    }
  }
  if (resultType == null) {
    resultType=JSType.UNKNOWN;
  }
  return new EnvTypePair(pair.env,resultType);
}
