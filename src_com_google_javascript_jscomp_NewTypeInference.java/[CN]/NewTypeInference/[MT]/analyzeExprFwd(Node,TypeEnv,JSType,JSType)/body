{
  Preconditions.checkArgument(requiredType != null && !requiredType.isBottom());
  EnvTypePair resultPair=null;
switch (expr.getType()) {
case Token.EMPTY:
    resultPair=new EnvTypePair(inEnv,JSType.UNKNOWN);
  break;
case Token.FUNCTION:
{
  String fnName=symbolTable.getFunInternalName(expr);
  JSType fnType=envGetType(inEnv,fnName);
  Preconditions.checkState(fnType != null,"Could not find type for %s",fnName);
  TypeEnv outEnv=collectTypesForFreeVarsFwd(expr,inEnv);
  resultPair=new EnvTypePair(outEnv,fnType);
  break;
}
case Token.FALSE:
case Token.NULL:
case Token.NUMBER:
case Token.STRING:
case Token.TRUE:
resultPair=new EnvTypePair(inEnv,scalarValueToType(expr.getType()));
break;
case Token.OBJECTLIT:
resultPair=analyzeObjLitFwd(expr,inEnv,requiredType,specializedType);
break;
case Token.THIS:
{
if (!currentScope.hasThis()) {
mayWarnAboutGlobalThis(expr,currentScope);
resultPair=new EnvTypePair(inEnv,JSType.UNKNOWN);
}
 else {
JSType inferredType=envGetType(inEnv,THIS_ID);
if (!inferredType.isSubtypeOf(requiredType)) {
return new EnvTypePair(inEnv,inferredType);
}
JSType preciseType=inferredType.specialize(specializedType);
resultPair=EnvTypePair.addBinding(inEnv,THIS_ID,preciseType);
}
break;
}
case Token.NAME:
resultPair=analyzeNameFwd(expr,inEnv,requiredType,specializedType);
break;
case Token.AND:
case Token.OR:
resultPair=analyzeLogicalOpFwd(expr,inEnv,requiredType,specializedType);
break;
case Token.INC:
case Token.DEC:
resultPair=analyzeIncDecFwd(expr,inEnv,requiredType);
break;
case Token.BITNOT:
case Token.NEG:
resultPair=analyzeUnaryNumFwd(expr,inEnv);
break;
case Token.POS:
{
resultPair=analyzeExprFwd(expr.getFirstChild(),inEnv);
resultPair.type=JSType.NUMBER;
break;
}
case Token.TYPEOF:
{
resultPair=analyzeExprFwd(expr.getFirstChild(),inEnv);
resultPair.type=JSType.STRING;
break;
}
case Token.INSTANCEOF:
resultPair=analyzeInstanceofFwd(expr,inEnv,specializedType);
break;
case Token.ADD:
resultPair=analyzeAddFwd(expr,inEnv,requiredType);
break;
case Token.BITOR:
case Token.BITAND:
case Token.BITXOR:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
resultPair=analyzeBinaryNumericOpFwd(expr,inEnv);
break;
case Token.ASSIGN:
resultPair=analyzeAssignFwd(expr,inEnv,requiredType,specializedType);
break;
case Token.ASSIGN_ADD:
resultPair=analyzeAssignAddFwd(expr,inEnv,requiredType);
break;
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
resultPair=analyzeAssignNumericOpFwd(expr,inEnv);
break;
case Token.SHEQ:
case Token.SHNE:
resultPair=analyzeStrictComparisonFwd(expr.getType(),expr.getFirstChild(),expr.getLastChild(),inEnv,specializedType);
break;
case Token.EQ:
case Token.NE:
resultPair=analyzeNonStrictComparisonFwd(expr,inEnv,specializedType);
break;
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
resultPair=analyzeLtGtFwd(expr,inEnv);
break;
case Token.GETPROP:
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()) || !NodeUtil.isLValue(expr));
if (expr.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
expr.removeProp(Node.ANALYZED_DURING_GTI);
resultPair=new EnvTypePair(inEnv,requiredType);
}
 else {
resultPair=analyzePropAccessFwd(expr.getFirstChild(),expr.getLastChild().getString(),inEnv,requiredType,specializedType);
}
break;
case Token.HOOK:
resultPair=analyzeHookFwd(expr,inEnv,requiredType,specializedType);
break;
case Token.CALL:
case Token.NEW:
resultPair=analyzeCallNewFwd(expr,inEnv,requiredType,specializedType);
break;
case Token.COMMA:
resultPair=analyzeExprFwd(expr.getLastChild(),analyzeExprFwd(expr.getFirstChild(),inEnv).env,requiredType,specializedType);
break;
case Token.NOT:
{
resultPair=analyzeExprFwd(expr.getFirstChild(),inEnv,JSType.UNKNOWN,specializedType.negate());
resultPair.type=resultPair.type.negate().toBoolean();
break;
}
case Token.GETELEM:
resultPair=analyzeGetElemFwd(expr,inEnv,requiredType,specializedType);
break;
case Token.VOID:
{
resultPair=analyzeExprFwd(expr.getFirstChild(),inEnv);
resultPair.type=JSType.UNDEFINED;
break;
}
case Token.IN:
resultPair=analyzeInFwd(expr,inEnv,specializedType);
break;
case Token.DELPROP:
{
resultPair=analyzeExprFwd(expr.getFirstChild(),inEnv);
resultPair.type=JSType.BOOLEAN;
break;
}
case Token.REGEXP:
resultPair=new EnvTypePair(inEnv,commonTypes.getRegexpType());
break;
case Token.ARRAYLIT:
resultPair=analyzeArrayLitFwd(expr,inEnv);
break;
case Token.CAST:
resultPair=analyzeCastFwd(expr,inEnv);
break;
case Token.CASE:
resultPair=analyzeStrictComparisonFwd(Token.SHEQ,expr.getParent().getFirstChild(),expr.getFirstChild(),inEnv,specializedType);
break;
default :
throw new RuntimeException("Unhandled expression type: " + Token.name(expr.getType()));
}
maybeSetTypeI(expr,resultPair.type);
if (this.currentScope.isFunction()) {
println("AnalyzeExprFWD: ",expr," ::reqtype: ",requiredType," ::spectype: ",specializedType," ::resulttype: ",resultPair.type);
}
return resultPair;
}
