{
  Preconditions.checkArgument(requiredType != null && !requiredType.isBottom());
switch (expr.getType()) {
case Token.EMPTY:
    return new EnvTypePair(inEnv,JSType.UNKNOWN);
case Token.FUNCTION:
{
    String fnName=symbolTable.getFunInternalName(expr);
    JSType fnType=envGetType(inEnv,fnName);
    Preconditions.checkState(fnType != null,"Could not find type for %s",fnName);
    return new EnvTypePair(inEnv,fnType);
  }
case Token.FALSE:
case Token.NULL:
case Token.NUMBER:
case Token.STRING:
case Token.TRUE:
return new EnvTypePair(inEnv,scalarValueToType(expr.getType()));
case Token.OBJECTLIT:
return analyzeObjLitFwd(expr,inEnv,requiredType,specializedType);
case Token.THIS:
{
if (!currentScope.hasThis()) {
warnings.add(JSError.make(expr,CheckGlobalThis.GLOBAL_THIS));
return new EnvTypePair(inEnv,JSType.UNKNOWN);
}
JSType thisType=currentScope.getDeclaredTypeOf("this");
return new EnvTypePair(inEnv,thisType);
}
case Token.NAME:
return analyzeNameFwd(expr,inEnv,requiredType,specializedType);
case Token.AND:
case Token.OR:
return analyzeLogicalOpFwd(expr,inEnv,requiredType,specializedType);
case Token.INC:
case Token.DEC:
return analyzeIncDecFwd(expr,inEnv,requiredType);
case Token.BITNOT:
case Token.POS:
case Token.NEG:
return analyzeUnaryNumFwd(expr,inEnv);
case Token.TYPEOF:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.STRING;
return pair;
}
case Token.INSTANCEOF:
return analyzeInstanceofFwd(expr,inEnv,specializedType);
case Token.ADD:
return analyzeAddFwd(expr,inEnv);
case Token.BITOR:
case Token.BITAND:
case Token.BITXOR:
case Token.DIV:
case Token.LSH:
case Token.MOD:
case Token.MUL:
case Token.RSH:
case Token.SUB:
case Token.URSH:
return analyzeBinaryNumericOpFwd(expr,inEnv);
case Token.ASSIGN:
return analyzeAssignFwd(expr,inEnv,requiredType,specializedType);
case Token.ASSIGN_ADD:
return analyzeAssignAddFwd(expr,inEnv,requiredType);
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
return analyzeAssignNumericOpFwd(expr,inEnv);
case Token.SHEQ:
case Token.SHNE:
return analyzeStrictComparisonFwd(expr.getType(),expr.getFirstChild(),expr.getLastChild(),inEnv,specializedType);
case Token.EQ:
case Token.NE:
return analyzeNonStrictComparisonFwd(expr,inEnv,specializedType);
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
return analyzeLtGtFwd(expr,inEnv);
case Token.GETPROP:
Preconditions.checkState(!NodeUtil.isAssignmentOp(expr.getParent()) || !NodeUtil.isLValue(expr));
if (expr.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
expr.removeProp(Node.ANALYZED_DURING_GTI);
return new EnvTypePair(inEnv,requiredType);
}
return analyzePropAccessFwd(expr.getFirstChild(),expr.getLastChild().getString(),inEnv,requiredType,specializedType);
case Token.HOOK:
return analyzeHookFwd(expr,inEnv,requiredType,specializedType);
case Token.CALL:
case Token.NEW:
return analyzeCallNewFwd(expr,inEnv,requiredType,specializedType);
case Token.COMMA:
return analyzeExprFwd(expr.getLastChild(),analyzeExprFwd(expr.getFirstChild(),inEnv).env,requiredType,specializedType);
case Token.NOT:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv,JSType.UNKNOWN,specializedType.negate());
pair.type=pair.type.negate().toBoolean();
return pair;
}
case Token.GETELEM:
return analyzeGetElemFwd(expr,inEnv,requiredType,specializedType);
case Token.VOID:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.UNDEFINED;
return pair;
}
case Token.IN:
return analyzeInFwd(expr,inEnv,specializedType);
case Token.DELPROP:
{
EnvTypePair pair=analyzeExprFwd(expr.getFirstChild(),inEnv);
pair.type=JSType.BOOLEAN;
return pair;
}
case Token.REGEXP:
return new EnvTypePair(inEnv,commonTypes.getRegexpType());
case Token.ARRAYLIT:
return analyzeArrayLitFwd(expr,inEnv);
case Token.CAST:
return analyzeCastFwd(expr,inEnv);
case Token.CASE:
return analyzeStrictComparisonFwd(Token.SHEQ,expr.getParent().getFirstChild(),expr.getFirstChild(),inEnv,specializedType);
default :
throw new RuntimeException("Unhandled expression type: " + Token.name(expr.getType()));
}
}
