{
switch (n.getType()) {
case Token.LABEL:
    validateLabel(n);
  return;
case Token.BLOCK:
validateBlock(n);
return;
case Token.FUNCTION:
if (isAmbient) {
validateFunctionSignature(n);
}
 else {
validateFunctionStatement(n);
}
return;
case Token.WITH:
validateWith(n);
return;
case Token.FOR:
validateFor(n);
return;
case Token.FOR_OF:
validateForOf(n);
return;
case Token.WHILE:
validateWhile(n);
return;
case Token.DO:
validateDo(n);
return;
case Token.SWITCH:
validateSwitch(n);
return;
case Token.IF:
validateIf(n);
return;
case Token.VAR:
case Token.LET:
case Token.CONST:
validateNameDeclarationHelper(n.getType(),n);
return;
case Token.EXPR_RESULT:
validateExprStmt(n);
return;
case Token.RETURN:
validateReturn(n);
return;
case Token.THROW:
validateThrow(n);
return;
case Token.TRY:
validateTry(n);
return;
case Token.BREAK:
validateBreak(n);
return;
case Token.CONTINUE:
validateContinue(n);
return;
case Token.EMPTY:
case Token.DEBUGGER:
validateChildless(n);
return;
case Token.CLASS:
validateClassDeclaration(n,isAmbient);
return;
case Token.IMPORT:
validateImport(n);
return;
case Token.EXPORT:
validateExport(n,isAmbient);
return;
case Token.INTERFACE:
validateInterface(n);
return;
case Token.ENUM:
validateEnum(n);
return;
case Token.TYPE_ALIAS:
validateTypeAlias(n);
return;
case Token.DECLARE:
validateAmbientDeclaration(n);
return;
case Token.MODULE:
validateModule(n,isAmbient);
return;
default :
violation("Expected statement but was " + Token.name(n.getType()) + ".",n);
}
}
