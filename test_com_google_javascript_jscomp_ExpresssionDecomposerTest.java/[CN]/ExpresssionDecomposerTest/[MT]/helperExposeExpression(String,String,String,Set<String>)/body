{
  Compiler compiler=new Compiler();
  if (knownConstants == null) {
    knownConstants=Sets.newHashSet();
  }
  ExpressionDecomposer decomposer=new ExpressionDecomposer(compiler,compiler.getUniqueNameIdSupplier(),knownConstants);
  decomposer.setTempNamePrefix("temp");
  Node expectedRoot=parse(compiler,expectedResult);
  Node tree=parse(compiler,code);
  assertNotNull(tree);
  Node externsRoot=new Node(Token.EMPTY);
  Node mainRoot=tree;
  Node callSite=findCall(tree,fnName);
  assertNotNull("Call to " + fnName + " was not found.",callSite);
  DecompositionType result=decomposer.canExposeExpression(callSite);
  assertTrue(result == DecompositionType.DECOMPOSABLE);
  compiler.resetUniqueNameId();
  decomposer.exposeExpression(callSite);
  validateSourceInfo(compiler,tree);
  String explanation=expectedRoot.checkTreeEquals(tree);
  assertNull("\nExpected: " + compiler.toSource(expectedRoot) + "\nResult: "+ compiler.toSource(tree)+ "\n"+ explanation,explanation);
}
