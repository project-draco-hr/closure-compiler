{
  Preconditions.checkArgument(n.getType() == Token.ASSIGN);
  if (!right.hasChildren() || right.getFirstChild().getNext() != right.getLastChild()) {
    return;
  }
  if (NodeUtil.mayHaveSideEffects(left)) {
    return;
  }
  Node leftChild=right.getFirstChild();
  if (!left.checkTreeEqualsSilent(leftChild)) {
    return;
  }
  int newType=-1;
switch (right.getType()) {
case Token.ADD:
    newType=Token.ASSIGN_ADD;
  break;
case Token.BITAND:
newType=Token.ASSIGN_BITAND;
break;
case Token.BITOR:
newType=Token.ASSIGN_BITOR;
break;
case Token.BITXOR:
newType=Token.ASSIGN_BITXOR;
break;
case Token.DIV:
newType=Token.ASSIGN_DIV;
break;
case Token.LSH:
newType=Token.ASSIGN_LSH;
break;
case Token.MOD:
newType=Token.ASSIGN_MOD;
break;
case Token.MUL:
newType=Token.ASSIGN_MUL;
break;
case Token.RSH:
newType=Token.ASSIGN_RSH;
break;
case Token.SUB:
newType=Token.ASSIGN_SUB;
break;
case Token.URSH:
newType=Token.ASSIGN_URSH;
break;
default :
return;
}
n.getParent().replaceChild(n,new Node(newType,left.detachFromParent(),right.getLastChild().detachFromParent()));
t.getCompiler().reportCodeChange();
}
