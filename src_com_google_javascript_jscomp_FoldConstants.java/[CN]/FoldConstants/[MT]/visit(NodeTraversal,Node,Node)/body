{
  int type=n.getType();
  if (type == Token.BLOCK) {
    tryFoldBlock(t,n,parent);
    return;
  }
  Node left=n.getFirstChild();
  if (left == null) {
    return;
  }
  if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
    String newValue=null;
switch (left.getType()) {
case Token.STRING:
      newValue="string";
    break;
case Token.NUMBER:
  newValue="number";
break;
case Token.TRUE:
case Token.FALSE:
newValue="boolean";
break;
case Token.NULL:
case Token.OBJECTLIT:
case Token.ARRAYLIT:
newValue="object";
break;
case Token.NAME:
if ("undefined".equals(left.getString())) {
newValue="undefined";
}
break;
}
if (newValue != null) {
parent.replaceChild(n,Node.newString(newValue));
t.getCompiler().reportCodeChange();
}
return;
}
if (type == Token.NOT || type == Token.NEG || type == Token.BITNOT) {
Preconditions.checkState(n.hasOneChild());
if (NodeUtil.isExpressionNode(parent)) {
parent.replaceChild(n,n.removeFirstChild());
t.getCompiler().reportCodeChange();
return;
}
if (type == Token.NOT && tryMinimizeNot(t,n,parent)) {
return;
}
if (!NodeUtil.isLiteralValue(left)) {
return;
}
switch (type) {
case Token.NOT:
int result=NodeUtil.getBooleanValue(left) ? Token.FALSE : Token.TRUE;
parent.replaceChild(n,new Node(result));
t.getCompiler().reportCodeChange();
break;
case Token.NEG:
try {
if (left.getType() == Token.NAME) {
if (left.getString().equals("Infinity")) {
return;
}
 else if (left.getString().equals("NaN")) {
n.removeChild(left);
parent.replaceChild(n,left);
t.getCompiler().reportCodeChange();
return;
}
}
double negNum=-left.getDouble();
parent.replaceChild(n,Node.newNumber(negNum));
t.getCompiler().reportCodeChange();
}
 catch (UnsupportedOperationException ex) {
error(t,NEGATING_A_NON_NUMBER_ERROR,left);
}
break;
case Token.BITNOT:
try {
double val=left.getDouble();
if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
int intVal=(int)val;
if (intVal == val) {
parent.replaceChild(n,Node.newNumber(~intVal));
t.getCompiler().reportCodeChange();
}
 else {
error(t,FRACTIONAL_BITWISE_OPERAND,left);
}
}
 else {
error(t,BITWISE_OPERAND_OUT_OF_RANGE,left);
}
}
 catch (UnsupportedOperationException ex) {
error(t,NEGATING_A_NON_NUMBER_ERROR,left);
}
break;
}
return;
}
 else if (type == Token.NEW) {
if (Token.NAME == left.getType()) {
String className=left.getString();
if ("RegExp".equals(className)) {
tryFoldRegularExpressionConstructor(t,n,parent);
}
 else if (left.getNext() == null) {
if ("Array".equals(className)) {
tryFoldLiteralConstructor(t,n,parent,className,Token.ARRAYLIT);
}
 else if ("Object".equals(className)) {
tryFoldLiteralConstructor(t,n,parent,className,Token.OBJECTLIT);
}
}
}
}
if (type == Token.EXPR_RESULT) {
tryMinimizeCondition(t,left,n);
return;
}
if (type == Token.RETURN) {
tryReduceReturn(t,n);
return;
}
Node right=left.getNext();
if (right == null) {
return;
}
if (type == Token.INSTANCEOF && NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
if (NodeUtil.isImmutableValue(left)) {
parent.replaceChild(n,new Node(Token.FALSE));
t.getCompiler().reportCodeChange();
return;
}
if (right.getType() == Token.NAME && "Object".equals(right.getString())) {
parent.replaceChild(n,new Node(Token.TRUE));
t.getCompiler().reportCodeChange();
return;
}
}
if (type == Token.IF || type == Token.HOOK) {
tryMinimizeCondition(t,n.getFirstChild(),n);
boolean changes=tryFoldHookIf(t,n,parent);
if (type == Token.IF && !changes) {
tryMinimizeIf(t,n,parent);
}
return;
}
if (type == Token.DO) {
tryMinimizeCondition(t,NodeUtil.getConditionExpression(n),n);
tryFoldDo(t,n,parent);
return;
}
if (type == Token.WHILE) {
tryMinimizeCondition(t,NodeUtil.getConditionExpression(n),n);
tryFoldWhile(t,n,parent);
return;
}
if (type == Token.FOR) {
Node condition=NodeUtil.getConditionExpression(n);
if (condition != null) {
tryMinimizeCondition(t,condition,n);
condition=NodeUtil.getConditionExpression(n);
this.tryFoldForCondition(condition,n);
}
tryFoldFor(t,n,parent);
return;
}
if (type == Token.AND || type == Token.OR) {
tryFoldAndOr(t,n,left,right,parent);
return;
}
if (type == Token.BITOR || type == Token.BITAND) {
tryFoldBitAndOr(t,n,left,right,parent);
return;
}
if (type == Token.LSH || type == Token.RSH || type == Token.URSH) {
tryFoldShift(t,n,left,right,parent);
return;
}
if (type == Token.GETPROP) {
tryFoldGetProp(t,n,left,right,parent);
return;
}
if (type == Token.CALL) {
tryFoldStringJoin(t,n,left,right,parent);
tryFoldStringIndexOf(t,n,left,right,parent);
return;
}
if (type == Token.ASSIGN) {
tryFoldAssign(t,n,left,right);
}
if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
if (type == Token.ADD) tryFoldLeftChildAdd(t,n,left,right,parent);
if (type == Token.LT || type == Token.GT) {
tryFoldComparison(t,n,left,right,parent);
}
return;
}
if (type == Token.ADD) {
tryFoldAdd(t,n,left,right,parent);
return;
}
if (type == Token.SUB || type == Token.MUL || type == Token.DIV) {
tryFoldArithmetic(t,n,left,right,parent);
return;
}
if (type == Token.LT || type == Token.GT || type == Token.LE || type == Token.GE || type == Token.EQ || type == Token.NE || type == Token.SHEQ || type == Token.SHNE) {
tryFoldComparison(t,n,left,right,parent);
return;
}
if (type == Token.GETELEM) {
tryFoldGetElem(t,n,left,right,parent);
return;
}
}
