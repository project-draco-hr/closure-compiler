{
  FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
  String functionPrivateName=n.getFirstChild().getString();
  if (functionType.isConstructor()) {
    FunctionType baseConstructor=functionType.getSuperClassConstructor();
    if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && baseConstructor != null && baseConstructor.isInterface() && functionType.isConstructor()) {
      compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"constructor",functionPrivateName));
    }
 else {
      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && baseConstructor != null) {
        if (functionType.makesStructs() && !baseConstructor.makesStructs()) {
          compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"struct",functionPrivateName));
        }
 else         if (functionType.makesDicts() && !baseConstructor.makesDicts()) {
          compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"dict",functionPrivateName));
        }
      }
      for (      JSType baseInterface : functionType.getImplementedInterfaces()) {
        boolean badImplementedType=false;
        ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
        if (baseInterfaceObj != null) {
          FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
          if (interfaceConstructor != null && !interfaceConstructor.isInterface()) {
            badImplementedType=true;
          }
        }
 else {
          badImplementedType=true;
        }
        if (badImplementedType) {
          report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
        }
      }
      validator.expectAllInterfaceProperties(t,n,functionType);
    }
  }
 else   if (functionType.isInterface()) {
    for (    ObjectType extInterface : functionType.getExtendedInterfaces()) {
      if (extInterface.getConstructor() != null && !extInterface.getConstructor().isInterface()) {
        compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,"interface",functionPrivateName));
      }
    }
    if (functionType.hasImplementedInterfaces()) {
      compiler.report(t.makeError(n,CONFLICTING_IMPLEMENTED_TYPE,functionPrivateName));
    }
    if (functionType.getExtendedInterfacesCount() > 1) {
      HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
      HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
      for (      ObjectType interfaceType : functionType.getExtendedInterfaces()) {
        currentProperties.clear();
        checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
        properties.putAll(currentProperties);
      }
    }
  }
}
