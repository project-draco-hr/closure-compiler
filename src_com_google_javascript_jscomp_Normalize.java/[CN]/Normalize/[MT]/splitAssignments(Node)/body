{
  for (Node next, c=n.getFirstChild(); c != null; c=next) {
    next=c.getNext();
    if (NodeUtil.isExpressionNode(c)) {
      Node expression=c;
      while (isCompoundAssignment(expression.getFirstChild())) {
        Node assign=expression.getFirstChild();
        Node rhs=assign.getLastChild();
        Node nameNode=rhs.getFirstChild();
        if (NodeUtil.mayEffectMutableState(nameNode)) {
          break;
        }
        assign.removeChild(rhs);
        assign.addChildToBack(nameNode.cloneTree());
        Node newChild=NodeUtil.newExpr(rhs);
        n.addChildBefore(newChild,expression);
        expression=newChild;
        compiler.reportCodeChange();
      }
    }
  }
}
