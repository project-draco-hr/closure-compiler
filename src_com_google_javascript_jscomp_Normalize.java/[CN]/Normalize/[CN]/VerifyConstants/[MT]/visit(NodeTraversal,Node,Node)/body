{
  if (n.getType() == Token.NAME) {
    String name=n.getString();
    if (n.getString().isEmpty()) {
      return;
    }
    boolean isConst=n.getBooleanProp(Node.IS_CONSTANT_NAME);
    if (checkUserDeclarations) {
      boolean expectedConst=false;
      CodingConvention convention=compiler.getCodingConvention();
      if (NodeUtil.isConstantName(n) || NodeUtil.isConstantByConvention(convention,n,parent)) {
        expectedConst=true;
      }
 else {
        expectedConst=false;
        JSDocInfo info=null;
        Var var=t.getScope().getVar(n.getString());
        if (var != null) {
          info=var.getJSDocInfo();
        }
        if (info != null && info.isConstant()) {
          expectedConst=true;
        }
 else {
          expectedConst=false;
        }
      }
      if (expectedConst) {
        Preconditions.checkState(expectedConst == isConst,"The name " + name + " is not annotated as constant.");
      }
 else {
        Preconditions.checkState(expectedConst == isConst,"The name " + name + " should not be annotated as constant.");
      }
    }
    Boolean value=constantMap.get(name);
    if (value == null) {
      constantMap.put(name,isConst);
    }
 else {
      Preconditions.checkState(value.booleanValue() == isConst,"The name " + name + " is not consistently annotated as "+ "constant.");
    }
  }
}
