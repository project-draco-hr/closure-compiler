{
  typeCheck("/**\n" + " * @template T\n" + " * @constructor\n"+ " * @param {T} x\n"+ " */\n"+ "function Foo(x) {}\n"+ "/** @param {Bar<T>} x */\n"+ "Foo.prototype.method = function(x) {};\n"+ "/**\n"+ " * @template T\n"+ " * @constructor\n"+ " * @param {T} x\n"+ " */\n"+ "function Bar(x) {}\n"+ "/** @param {Foo<T>} x */\n"+ "Bar.prototype.method = function(x) {};\n"+ "(new Foo(123)).method(new Bar('asdf'));",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck("/**\n" + " * @template T\n" + " * @constructor\n"+ " * @param {T} x\n"+ " */\n"+ "function Foo(x) {}\n"+ "/** @param {Foo<Foo<T>>} x */\n"+ "Foo.prototype.method = function(x) {};\n"+ "(new Foo(123)).method(new Foo(new Foo('asdf')));",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck("/** @interface\n @template T */function A() {};" + "/** @return {T} */A.prototype.foo = function() {};" + "/** @interface\n @template U\n @extends {A<U>} */function B() {};"+ "/** @constructor\n @implements {B<string>} */function C() {};"+ "/** @return {string}\n @override */\n"+ "C.prototype.foo = function() { return 123; };",NewTypeInference.RETURN_NONDECLARED_TYPE);
  typeCheck("/**\n" + " * @constructor\n" + " * @template T\n"+ " * @param {T} x\n"+ " */\n"+ "function Foo(x) {}\n"+ "/**\n"+ " * @template U\n"+ " * @param {U} x\n"+ " * @return {U}\n"+ " */\n"+ "Foo.prototype.method = function(x) { return x; };\n"+ "(new Foo(123)).method('asdf') - 5;",NewTypeInference.INVALID_OPERAND_TYPE);
}
