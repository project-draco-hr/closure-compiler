{
  typeCheck("/** @interface */ function I() {}\n" + "/** @type {string} */ I.prototype.prop;\n" + "/** @constructor @implements{I} */ function C() {}",TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED);
  typeCheck("/** @interface */ function I() {}\n" + "/** @param {number} x */\n" + "I.prototype.method = function(x) {};\n"+ "/** @constructor @implements{I} */ function C() {}",TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED);
  typeCheck("/** @interface */ function IParent() {}\n" + "/** @type {number} */ IParent.prototype.prop;\n" + "/** @interface @extends{IParent} */ function IChild() {}\n"+ "/** @constructor @implements{IChild} */\n"+ "function C() { this.prop = 5; }\n"+ "(new C).prop < 'adsf';",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck("/** @interface */ function IParent() {}\n" + "/** @type {number} */ IParent.prototype.prop;\n" + "/** @interface @extends{IParent} */ function IChild() {}\n"+ "/** @constructor @implements{IChild} */\n"+ "function C() { this.prop = 'str'; }",NewTypeInference.MISTYPED_ASSIGN_RHS);
  checkNoWarnings("/** @constructor */\n" + "function Parent() { /** @type {number} */ this.prop = 123; }\n" + "/** @constructor @extends {Parent} */ function Child() {}\n"+ "(new Child).prop = 321;");
  typeCheck("/** @constructor */\n" + "function Parent() { /** @type {number} */ this.prop = 123; }\n" + "/** @constructor @extends {Parent} */ function Child() {}\n"+ "(new Child).prop = 'str';",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck("/** @interface */ function I() {}\n" + "/** @param {number} x */\n" + "I.prototype.method = function(x, y) {};\n"+ "/** @constructor @implements{I} */ function C() {}\n"+ "/** @param {string} y */\n"+ "C.prototype.method = function(x, y) {};\n"+ "(new C).method(5, 6);",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck("/** @interface */ function I() {}\n" + "/** @param {number} x */\n" + "I.prototype.method = function(x, y) {};\n"+ "/** @constructor @implements{I} */ function C() {}\n"+ "/** @param {string} y */\n"+ "C.prototype.method = function(x, y) {};\n"+ "(new C).method('asdf', 'fgr');",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck("/** @interface */ function I() {}\n" + "/** @param {number} x */\n" + "I.prototype.method = function(x) {};\n"+ "/** @constructor @implements{I} */ function C() {}\n"+ "C.prototype.method = function(x) {};\n"+ "(new C).method('asdf');",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck("/** @interface */ function I1() {}\n" + "/** @param {number} x */ I1.prototype.method = function(x, y) {};\n" + "/** @interface */ function I2() {}\n"+ "/** @param {string} y */ I2.prototype.method = function(x, y) {};\n"+ "/** @constructor @implements{I1} @implements{I2} */ function C(){}\n"+ "C.prototype.method = function(x, y) {};\n"+ "(new C).method('asdf', 'fgr');",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck("/** @interface */ function I1() {}\n" + "/** @param {number} x */ I1.prototype.method = function(x, y) {};\n" + "/** @interface */ function I2() {}\n"+ "/** @param {string} y */ I2.prototype.method = function(x, y) {};\n"+ "/** @constructor @implements{I1} @implements{I2} */ function C(){}\n"+ "C.prototype.method = function(x, y) {};\n"+ "(new C).method(1, 2);",NewTypeInference.INVALID_ARGUMENT_TYPE);
  checkNoWarnings("/** @interface */ function I1() {}\n" + "/** @param {number} x */ I1.prototype.method = function(x) {};\n" + "/** @interface */ function I2() {}\n"+ "/** @param {string} x */ I2.prototype.method = function(x) {};\n"+ "/** @constructor @implements{I1} @implements{I2} */ function C(){}\n"+ "C.prototype.method = function(x) {};");
  typeCheck("/** @interface */ function I1() {}\n" + "/** @param {number} x */ I1.prototype.method = function(x) {};\n" + "/** @interface */ function I2() {}\n"+ "/** @param {string} x */ I2.prototype.method = function(x) {};\n"+ "/** @constructor @implements{I1} @implements{I2} */ function C(){}\n"+ "C.prototype.method = function(x) {};\n"+ "(new C).method(true);",NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck("/** @interface */ function I() {}\n" + "/** @param {number} x */ I.prototype.method = function(x) {};\n" + "/** @constructor */ function S() {}\n"+ "/** @param {string} x */ S.prototype.method = function(x) {};\n"+ "/** @constructor @implements{I} @extends{S} */ function C(){}\n"+ "C.prototype.method = function(x) {};\n"+ "(new C).method(true);",NewTypeInference.INVALID_ARGUMENT_TYPE);
}
