{
  Preconditions.checkArgument(budget >= 1);
  Map<Expression,Double> pmf=Maps.newHashMap();
  for (  Expression expr : Expression.values()) {
    if (expr.minBudget <= budget) {
      if (expr == Expression.FUNCTION_CALL && symbolTable.getSize() == 0 && budget < 4) {
        continue;
      }
 else       if (expr == Expression.IDENTIFIER && symbolTable.getSize() == 0) {
        continue;
      }
 else {
        pmf.put(expr,expr.weight);
      }
    }
  }
  DiscreteDistribution<Expression> dd=new DiscreteDistribution<Expression>(random,pmf);
  Expression expr=dd.nextItem();
switch (expr) {
case THIS:
    return generateThis(budget);
case IDENTIFIER:
  return generateIdentifier(budget,true);
case LITERAL:
return generateLiteral(budget);
case FUNCTION_CALL:
return generateFunctionCall(budget);
case UNARY_EXPR:
return generateUnaryExpression(budget);
case BINARY_EXPR:
return generateBinaryExpression(budget);
case FUNCTION_EXPR:
return generateFunctionExpression(budget);
case TERNARY_EXPR:
return generateTernaryExpression(budget);
}
return null;
}
