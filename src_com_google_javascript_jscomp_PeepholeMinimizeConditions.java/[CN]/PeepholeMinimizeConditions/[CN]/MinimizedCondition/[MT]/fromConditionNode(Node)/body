{
switch (n.getType()) {
case Token.NOT:
{
      MinimizedCondition subtree=fromConditionNode(n.getFirstChild());
      ImmutableSet<MeasuredNode> positiveAsts=ImmutableSet.of(subtree.positive.cloneTree().negate(),subtree.negative.cloneTree());
      ImmutableSet<MeasuredNode> negativeAsts=ImmutableSet.of(subtree.negative.negate(),subtree.positive);
      return new MinimizedCondition(Collections.min(positiveAsts,AST_LENGTH_COMPARATOR),Collections.min(negativeAsts,AST_LENGTH_COMPARATOR));
    }
case Token.AND:
case Token.OR:
{
    int opType=n.getType();
    int complementType=opType == Token.AND ? Token.OR : Token.AND;
    MinimizedCondition leftSubtree=fromConditionNode(n.getFirstChild());
    MinimizedCondition rightSubtree=fromConditionNode(n.getLastChild());
    ImmutableSet<MeasuredNode> positiveAsts=ImmutableSet.of(MeasuredNode.addNode(opType,n,leftSubtree.positive.cloneTree(),rightSubtree.positive.cloneTree()),MeasuredNode.addNode(complementType,n,leftSubtree.negative.cloneTree(),rightSubtree.negative.cloneTree()).negate());
    ImmutableSet<MeasuredNode> negativeAsts=ImmutableSet.of(MeasuredNode.addNode(opType,n,leftSubtree.positive,rightSubtree.positive).negate(),MeasuredNode.addNode(complementType,n,leftSubtree.negative,rightSubtree.negative));
    return new MinimizedCondition(Collections.min(positiveAsts,AST_LENGTH_COMPARATOR),Collections.min(negativeAsts,AST_LENGTH_COMPARATOR));
  }
default :
MeasuredNode pos=new MeasuredNode(n.cloneTree(),0);
MeasuredNode neg=pos.cloneTree().negate();
return new MinimizedCondition(pos,neg);
}
}
