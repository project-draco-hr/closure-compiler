{
  Node parent=n.getParent();
  Node first=n.getFirstChild();
switch (first.getType()) {
case Token.NOT:
{
      Node newRoot=first.removeFirstChild();
      parent.replaceChild(n,newRoot);
      reportCodeChange();
      return newRoot;
    }
case Token.AND:
case Token.OR:
{
    Node leftParent=first.getFirstChild();
    Node rightParent=first.getLastChild();
    Node left, right;
    if (!leftParent.isNot() && !rightParent.isNot()) {
      int opPrecedence=NodeUtil.precedence(first.getType());
      if ((isLowerPrecedence(leftParent,NOT_PRECEDENCE) && isHigherPrecedence(leftParent,opPrecedence)) || (isLowerPrecedence(rightParent,NOT_PRECEDENCE) && isHigherPrecedence(rightParent,opPrecedence))) {
        return n;
      }
    }
    if (leftParent.isNot()) {
      left=leftParent.removeFirstChild();
    }
 else {
      leftParent.detachFromParent();
      left=IR.not(leftParent).srcref(leftParent);
    }
    if (rightParent.isNot()) {
      right=rightParent.removeFirstChild();
    }
 else {
      rightParent.detachFromParent();
      right=IR.not(rightParent).srcref(rightParent);
    }
    int newOp=(first.isAnd()) ? Token.OR : Token.AND;
    Node newRoot=new Node(newOp,left,right);
    parent.replaceChild(n,newRoot);
    reportCodeChange();
    return newRoot;
  }
default :
TernaryValue nVal=NodeUtil.getPureBooleanValue(first);
if (nVal != TernaryValue.UNKNOWN) {
boolean result=nVal.not().toBoolean(true);
int equivalentResult=result ? 1 : 0;
return maybeReplaceChildWithNumber(n,parent,equivalentResult);
}
}
return n;
}
