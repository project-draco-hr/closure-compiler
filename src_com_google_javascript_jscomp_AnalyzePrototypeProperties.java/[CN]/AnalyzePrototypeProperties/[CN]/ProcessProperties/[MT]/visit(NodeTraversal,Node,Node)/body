{
  if (n.getType() == Token.GETPROP) {
    String propName=n.getFirstChild().getNext().getString();
    if (propName.equals("prototype")) {
      processPrototypeParent(t,parent);
    }
 else     if (compiler.getCodingConvention().isExported(propName)) {
      addGlobalUseOfSymbol(propName,t.getModule(),PROPERTY);
    }
 else {
      addSymbolUse(propName,t.getModule(),PROPERTY);
    }
  }
 else   if (n.getType() == Token.OBJECTLIT && !(parent.getType() == Token.ASSIGN && parent.getFirstChild().getType() == Token.GETPROP && parent.getFirstChild().getLastChild().getString().equals("prototype"))) {
    for (Node propNameNode=n.getFirstChild(); propNameNode != null; propNameNode=propNameNode.getNext()) {
      if (!propNameNode.isQuotedString()) {
        addSymbolUse(propNameNode.getString(),t.getModule(),PROPERTY);
      }
    }
  }
 else   if (n.getType() == Token.NAME) {
    String name=n.getString();
    Var var=t.getScope().getVar(name);
    if (var != null) {
      if (var.isGlobal()) {
        if (var.getInitialValue() != null && var.getInitialValue().getType() == Token.FUNCTION) {
          if (t.inGlobalScope()) {
            if (!processGlobalFunctionDeclaration(t,n,parent,parent.getParent())) {
              addGlobalUseOfSymbol(name,t.getModule(),VAR);
            }
          }
 else {
            addSymbolUse(name,t.getModule(),VAR);
          }
        }
      }
 else       if (var.getScope() != t.getScope()) {
        for (int i=symbolStack.size() - 1; i >= 0; i--) {
          NameContext context=symbolStack.get(i);
          context.name.readClosureVariables=true;
          if (context.scope == var.getScope()) {
            break;
          }
        }
      }
    }
  }
  if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t,n) || n.isFunction()) {
    symbolStack.pop();
  }
}
