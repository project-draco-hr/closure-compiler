{
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  assertTrue("Unexpected parse error(s): " + Joiner.on("\n").join(compiler.getErrors()),root != null);
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node rootClone=root.cloneTree();
  Node externsRootClone=rootClone.getFirstChild();
  Node mainRootClone=rootClone.getLastChild();
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=Lists.newArrayList();
  boolean hasCodeChanged=false;
  assertFalse("Code should not change before processing",recentChange.hasCodeChanged());
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager(compiler);
      if (typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,typeCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        Normalize normalize=new Normalize(compiler,false);
        normalize.process(externsRoot,mainRoot);
        compiler.setNormalized();
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      if (checkLineNumbers) {
        (new LineNumberCheck(compiler)).process(externsRoot,mainRoot);
      }
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      aggregateWarnings.addAll(Lists.newArrayList(compiler.getWarnings()));
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals("Unexpected error(s): " + Joiner.on("\n").join(compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableErrorManager=new BlackHoleErrorManager(compiler);
    Node expectedRoot=parseExpectedJs(expected);
    expectedRoot.detachFromParent();
    SymbolTable table=compiler.acquireSymbolTable();
    table.verify(new Node(Token.BLOCK,externsRoot.cloneTree(),expectedRoot),mainRoot.getParent());
    table.release();
    JSError[] stErrors=symbolTableErrorManager.getErrors();
    if (expectedSymbolTableError != null) {
      assertEquals("There should be one error.",1,stErrors.length);
      assertEquals(expectedSymbolTableError,stErrors[0].getType());
    }
 else {
      assertEquals("Unexpected symbol table error(s): " + Joiner.on("\n").join(stErrors),0,stErrors.length);
    }
    if (warning == null) {
      assertEquals("Unexpected warning(s): " + Joiner.on("\n").join(aggregateWarnings),0,aggregateWarningCount);
    }
 else {
      assertEquals("There should be one warning, repeated " + numRepetitions + " time(s).",numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertEquals(warning,actual.getType());
        if (!allowSourcelessWarnings) {
          assertTrue("Missing source file name in warning",actual.sourceName != null && !actual.sourceName.isEmpty());
          assertTrue("Missing line number in warning",-1 != actual.lineNumber);
          assertTrue("Missing char number in warning",-1 != actual.getCharno());
        }
        if (description != null) {
          assertEquals(description,actual.description);
        }
      }
    }
    if (normalizeEnabled) {
      Normalize normalize=new Normalize(compiler,false);
      normalize.process(externsRootClone,mainRootClone);
    }
    if (mainRootClone.checkTreeEqualsSilent(mainRoot)) {
      assertFalse("compiler.reportCodeChange() was called " + "even though nothing changed",hasCodeChanged);
    }
 else {
      assertTrue("compiler.reportCodeChange() should have been called",hasCodeChanged);
    }
    if (compareAsTree) {
      String explanation=expectedRoot.checkTreeEquals(mainRoot);
      assertNull("\nExpected: " + compiler.toSource(expectedRoot) + "\nResult: "+ compiler.toSource(mainRoot)+ "\n"+ explanation,explanation);
    }
 else     if (expected != null) {
      assertEquals(Joiner.on("").join(expected),compiler.toSource(mainRoot));
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=root.getFirstChild();
    Node normalizeCheckMainRootClone=root.getLastChild();
    new PrepareAst(compiler).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull("Node structure normalization invalidated.\nExpected: " + compiler.toSource(normalizeCheckMainRootClone) + "\nResult: "+ compiler.toSource(mainRoot)+ "\n"+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull("Normalization invalidated.\nExpected: " + compiler.toSource(normalizeCheckMainRootClone) + "\nResult: "+ compiler.toSource(mainRoot)+ "\n"+ explanation,explanation);
    }
  }
 else {
    String errors="";
    for (    JSError actualError : compiler.getErrors()) {
      errors+=actualError.description + "\n";
    }
    assertEquals("There should be one error. " + errors,1,compiler.getErrorCount());
    assertEquals(errors,error,compiler.getErrors()[0].getType());
  }
}
