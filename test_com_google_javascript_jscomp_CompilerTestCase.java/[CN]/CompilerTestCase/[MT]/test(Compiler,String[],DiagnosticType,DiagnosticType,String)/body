{
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  assertTrue("Unexpected parse error(s): " + Join.join("\n",compiler.getErrors()),root != null);
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node mainRootClone=mainRoot.cloneTree();
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=Lists.newArrayList();
  boolean hasCodeChanged=false;
  assertFalse("Code should not change before processing",recentChange.hasCodeChanged());
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager(compiler);
      if (typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,typeCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        Normalize normalize=new Normalize(compiler,false);
        normalize.process(externsRoot,mainRoot);
        compiler.setNormalized();
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      aggregateWarnings.addAll(Lists.newArrayList(compiler.getWarnings()));
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals("Unexpected error(s): " + Join.join("\n",compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableWarnings=new BlackHoleErrorManager(compiler);
    Node expectedRoot=parseExpectedJs(expected);
    SymbolTable table=compiler.acquireSymbolTable();
    table.verify(expectedRoot,mainRoot);
    table.release();
    if (warning == null) {
      assertEquals("Unexpected warning(s): " + Join.join("\n",aggregateWarnings),0,aggregateWarningCount);
    }
 else     if (symbolTableWarnings.getWarnings().length > 0) {
      JSError[] warnings=symbolTableWarnings.getWarnings();
      assertEquals("There should be one symbol table warning",1,warnings.length);
      assertEquals(warning,warnings[0].getType());
    }
 else {
      assertEquals("There should be one warning, repeated " + numRepetitions + " time(s).",numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertEquals(warning,actual.getType());
        if (!allowSourcelessWarnings) {
          assertTrue("Missing source file name in warning",actual.sourceName != null && !actual.sourceName.isEmpty());
          assertTrue("Missing line number in warning",-1 != actual.lineNumber);
          assertTrue("Missing char number in warning",-1 != actual.getCharno());
        }
        if (description != null) {
          assertEquals(description,actual.description);
        }
      }
    }
    if (normalizeEnabled) {
      Normalize normalize=new Normalize(compiler,false);
      normalize.process(externsRoot,mainRootClone);
    }
    if (mainRootClone.checkTreeEqualsSilent(mainRoot)) {
      assertFalse("compiler.reportCodeChange() was called " + "even though nothing changed",hasCodeChanged);
    }
 else {
      assertTrue("compiler.reportCodeChange() should have been called",hasCodeChanged);
    }
    if (compareAsTree) {
      String explanation=expectedRoot.checkTreeEquals(mainRoot);
      assertNull("\nExpected: " + compiler.toSource(expectedRoot) + "\nResult: "+ compiler.toSource(mainRoot)+ "\n"+ explanation,explanation);
    }
 else     if (expected != null) {
      assertEquals(Join.join("",expected),compiler.toSource(mainRoot));
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=root.getFirstChild();
    Node normalizeCheckMainRootClone=root.getLastChild();
    new NodeTypeNormalizer().process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull("Node structure normalization invalidated.\nExpected: " + compiler.toSource(normalizeCheckMainRootClone) + "\nResult: "+ compiler.toSource(mainRoot)+ "\n"+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull("Normalization invalidated.\nExpected: " + compiler.toSource(normalizeCheckMainRootClone) + "\nResult: "+ compiler.toSource(mainRoot)+ "\n"+ explanation,explanation);
    }
  }
 else {
    assertEquals("There should be one error.",1,compiler.getErrorCount());
    assertEquals(error,compiler.getErrors()[0].getType());
  }
}
