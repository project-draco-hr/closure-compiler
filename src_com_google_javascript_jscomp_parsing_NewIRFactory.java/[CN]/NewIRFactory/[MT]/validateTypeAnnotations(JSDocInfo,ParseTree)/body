{
  if (!ENABLE_TYPE_ANNOTATION_CHECKS) {
    return;
  }
  if (info.hasType()) {
    boolean valid=false;
switch (node.type) {
case PAREN_EXPRESSION:
      valid=true;
    break;
case VARIABLE_STATEMENT:
case VARIABLE_DECLARATION:
  valid=true;
break;
case FUNCTION_DECLARATION:
valid=isFunctionDeclaration(node.asFunctionDeclaration());
break;
case IDENTIFIER_EXPRESSION:
ParseTree parent=getParent(node);
valid=parent.type == ParseTreeType.PROPERTY_NAME_ASSIGNMENT || parent.type == ParseTreeType.GET_ACCESSOR || parent.type == ParseTreeType.SET_ACCESSOR || parent.type == ParseTreeType.CATCH || parent.type == ParseTreeType.FUNCTION_DECLARATION || (parent.type == ParseTreeType.VARIABLE_DECLARATION && node == (parent.asVariableDeclaration()).lvalue);
break;
case PROPERTY_NAME_ASSIGNMENT:
valid=true;
break;
case BINARY_OPERATOR:
BinaryOperatorTree binop=node.asBinaryOperator();
if (binop.operator.type == TokenType.EQUAL) {
valid=isExpressionStatement(getParent(node)) && isPropAccess(binop.left);
}
break;
case MEMBER_EXPRESSION:
case MEMBER_LOOKUP_EXPRESSION:
valid=isExpressionStatement(getParent(node));
break;
case CALL_EXPRESSION:
valid=info.isDefine();
break;
}
if (!valid) {
errorReporter.warning(MISPLACED_TYPE_ANNOTATION,sourceName,node.location.start.line,"",0);
}
}
}
