{
  Node enclosing=parent;
  Node potentialCallee=node;
  if (!parent.isCall()) {
    enclosing=parent.getParent();
    potentialCallee=parent;
  }
  if (!enclosing.isCall() || enclosing.getFirstChild() != potentialCallee) {
    compiler.report(JSError.make(node,CANNOT_CONVERT_YET,"Only calls to super or to a method of super are supported."));
    return;
  }
  Node clazz=NodeUtil.getEnclosingClass(node);
  if (clazz == null) {
    compiler.report(JSError.make(node,NO_SUPERTYPE));
    return;
  }
  if (NodeUtil.getClassNameNode(clazz) == null) {
    return;
  }
  Node enclosingMemberDef=NodeUtil.getEnclosingClassMember(node);
  if (enclosingMemberDef.isStaticMember()) {
    Node superName=clazz.getFirstChild().getNext();
    if (!superName.isQualifiedName()) {
      return;
    }
    Node callTarget;
    potentialCallee.detachFromParent();
    if (potentialCallee == node) {
      potentialCallee=IR.getprop(superName.cloneTree(),IR.string(enclosingMemberDef.getString()));
      enclosing.putBooleanProp(Node.FREE_CALL,false);
    }
 else {
      potentialCallee.replaceChild(node,superName.cloneTree());
    }
    callTarget=IR.getprop(potentialCallee,IR.string("call"));
    enclosing.addChildToFront(callTarget);
    enclosing.addChildAfter(IR.thisNode(),callTarget);
    enclosing.useSourceInfoIfMissingFromForTree(enclosing);
    compiler.reportCodeChange();
    return;
  }
  String methodName;
  Node callName=enclosing.removeFirstChild();
  if (callName.isSuper()) {
    methodName=enclosingMemberDef.getString();
  }
 else {
    methodName=callName.getLastChild().getString();
  }
  Node baseCall=baseCall(compiler,clazz,methodName,enclosing.removeChildren()).useSourceInfoIfMissingFromForTree(enclosing);
  enclosing.getParent().replaceChild(enclosing,baseCall);
  compiler.reportCodeChange();
}
