{
  CodingConvention convention=codingConvention;
  for (Iterator<Var> it=maybeUnreferenced.iterator(); it.hasNext(); ) {
    Var var=it.next();
    for (    Node exprCallNode : classDefiningCalls.get(var)) {
      NodeUtil.removeChild(exprCallNode.getParent(),exprCallNode);
      compiler.reportCodeChange();
    }
    removeAllAssigns(var);
    compiler.addToDebugLog("Unreferenced var: " + var.name);
    Node nameNode=var.nameNode;
    Node toRemove=nameNode.getParent();
    Node parent=toRemove.getParent();
    Preconditions.checkState(toRemove.isVar() || toRemove.isFunction() || toRemove.isParamList() && parent.isFunction(),"We should only declare vars and functions and function args");
    if (toRemove.isParamList() && parent.isFunction()) {
    }
 else     if (NodeUtil.isFunctionExpression(toRemove)) {
      if (!preserveFunctionExpressionNames) {
        toRemove.getFirstChild().setString("");
        compiler.reportCodeChange();
      }
    }
 else     if (parent != null && parent.isFor() && parent.getChildCount() < 4) {
    }
 else     if (toRemove.isVar() && nameNode.hasChildren() && NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(),compiler)) {
      if (toRemove.getChildCount() == 1) {
        parent.replaceChild(toRemove,IR.exprResult(nameNode.removeFirstChild()));
        compiler.reportCodeChange();
      }
    }
 else     if (toRemove.isVar() && toRemove.getChildCount() > 1) {
      toRemove.removeChild(nameNode);
      compiler.reportCodeChange();
    }
 else     if (parent != null) {
      NodeUtil.removeChild(parent,toRemove);
      compiler.reportCodeChange();
    }
  }
}
