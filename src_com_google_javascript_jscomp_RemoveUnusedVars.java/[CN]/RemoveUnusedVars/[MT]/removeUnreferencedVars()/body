{
  CodingConvention convention=codingConvention;
  for (Iterator<Var> it=maybeUnreferenced.iterator(); it.hasNext(); ) {
    Var var=it.next();
    for (    Node exprCallNode : inheritsCalls.get(var)) {
      NodeUtil.removeChild(exprCallNode.getParent(),exprCallNode);
      compiler.reportCodeChange();
    }
    removeAllAssigns(var);
    compiler.addToDebugLog("Unreferenced var: " + var.name);
    Node nameNode=var.nameNode;
    Node toRemove=nameNode.getParent();
    Node parent=toRemove.getParent();
    Preconditions.checkState(toRemove.getType() == Token.VAR || toRemove.getType() == Token.FUNCTION || toRemove.getType() == Token.LP && parent.getType() == Token.FUNCTION,"We should only declare vars and functions and function args");
    if (toRemove.getType() == Token.LP && parent.getType() == Token.FUNCTION) {
    }
 else     if (NodeUtil.isFunctionExpression(toRemove)) {
      if (!preserveFunctionExpressionNames) {
        toRemove.getFirstChild().setString("");
        compiler.reportCodeChange();
      }
    }
 else     if (parent != null && parent.getType() == Token.FOR && parent.getChildCount() < 4) {
    }
 else     if (toRemove.getType() == Token.VAR && nameNode.hasChildren() && NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {
      if (toRemove.getChildCount() == 1) {
        parent.replaceChild(toRemove,new Node(Token.EXPR_RESULT,nameNode.removeFirstChild()));
        compiler.reportCodeChange();
      }
    }
 else     if (toRemove.getType() == Token.VAR && toRemove.getChildCount() > 1) {
      toRemove.removeChild(nameNode);
      compiler.reportCodeChange();
    }
 else     if (parent != null) {
      NodeUtil.removeChild(parent,toRemove);
      compiler.reportCodeChange();
    }
  }
}
