{
  int type=n.getType();
  Var var=null;
switch (type) {
case Token.FUNCTION:
    if (NodeUtil.isFunctionDeclaration(n)) {
      var=scope.getVar(n.getFirstChild().getString());
    }
  if (var != null && isRemovableVar(var)) {
    continuations.put(var,new Continuation(n,scope));
  }
 else {
    traverseFunction(n,scope);
  }
return;
case Token.ASSIGN:
Assign maybeAssign=Assign.maybeCreateAssign(n);
if (maybeAssign != null) {
var=scope.getVar(maybeAssign.nameNode.getString());
if (var != null) {
assignsByVar.put(var,maybeAssign);
assignsByNode.put(maybeAssign.nameNode,maybeAssign);
if (isRemovableVar(var) && !maybeAssign.mayHaveSecondarySideEffects) {
  continuations.put(var,new Continuation(n,scope));
  return;
}
}
}
break;
case Token.CALL:
SubclassRelationship subclassRelationship=codingConvention.getClassesDefinedByCall(n);
if (subclassRelationship != null) {
Var subclassVar=scope.getVar(subclassRelationship.subclassName);
if (subclassVar != null && subclassVar.isGlobal() && !referenced.contains(subclassVar)) {
inheritsCalls.put(subclassVar,parent);
continuations.put(subclassVar,new Continuation(n,scope));
return;
}
}
break;
case Token.NAME:
var=scope.getVar(n.getString());
if (parent.getType() == Token.VAR) {
Node value=n.getFirstChild();
if (value != null && var != null && isRemovableVar(var) && !NodeUtil.mayHaveSideEffects(value)) {
continuations.put(var,new Continuation(n,scope));
return;
}
}
 else {
if ("arguments".equals(n.getString()) && scope.isLocal()) {
Node lp=scope.getRootNode().getFirstChild().getNext();
for (Node a=lp.getFirstChild(); a != null; a=a.getNext()) {
markReferencedVar(scope.getVar(a.getString()));
}
}
if (var != null) {
if (isRemovableVar(var)) {
if (!assignsByNode.containsKey(n)) {
markReferencedVar(var);
}
}
 else {
markReferencedVar(var);
}
}
}
break;
}
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
traverseNode(c,n,scope);
}
}
