{
  CodingConvention convention=compiler.getCodingConvention();
  for (Iterator<Var> it=scope.getVars(); it.hasNext(); ) {
    Var var=it.next();
    if (!referenced.contains(var) && (var.isLocal() || !convention.isExported(var.name))) {
      compiler.addToDebugLog("Unreferenced var: " + var.name);
      Node nameNode=var.nameNode;
      Node toRemove=nameNode.getParent();
      Node parent=toRemove.getParent();
      Preconditions.checkState(toRemove.getType() == Token.VAR || toRemove.getType() == Token.FUNCTION || toRemove.getType() == Token.LP && parent.getType() == Token.FUNCTION,"We should only declare vars and functions and function args");
      if (toRemove.getType() == Token.LP && parent.getType() == Token.FUNCTION) {
      }
 else       if (NodeUtil.isFunctionExpression(toRemove)) {
        if (!preserveFunctionExpressionNames) {
          toRemove.getFirstChild().setString("");
          compiler.reportCodeChange();
        }
      }
 else       if (parent != null && parent.getType() == Token.FOR && parent.getChildCount() < 4) {
      }
 else       if (toRemove.getType() == Token.VAR && nameNode.hasChildren() && NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {
        if (toRemove.getChildCount() == 1) {
          parent.replaceChild(toRemove,new Node(Token.EXPR_RESULT,nameNode.removeFirstChild()));
          numRemoved++;
        }
      }
 else       if (toRemove.getType() == Token.VAR && toRemove.getChildCount() > 1) {
        toRemove.removeChild(nameNode);
        numRemoved++;
      }
 else       if (parent != null) {
        NodeUtil.removeChild(parent,toRemove);
        numRemoved++;
      }
    }
  }
}
