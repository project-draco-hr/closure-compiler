{
  Node parent=node.getParent();
  if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {
    return null;
  }
switch (parent.getType()) {
case Token.IF:
    return computeFollowNode(fromNode,parent,cfa);
case Token.CASE:
case Token.DEFAULT_CASE:
  if (parent.getNext() != null) {
    if (parent.getNext().isCase()) {
      return parent.getNext().getSecondChild();
    }
 else     if (parent.getNext().isDefaultCase()) {
      return parent.getNext().getFirstChild();
    }
 else {
      throw new IllegalStateException("Not reachable");
    }
  }
 else {
    return computeFollowNode(fromNode,parent,cfa);
  }
case Token.FOR:
case Token.FOR_OF:
if (parent.isForOf() || NodeUtil.isForIn(parent)) {
  return parent;
}
 else {
  return parent.getSecondChild().getNext();
}
case Token.WHILE:
case Token.DO:
return parent;
case Token.TRY:
if (parent.getFirstChild() == node) {
if (NodeUtil.hasFinally(parent)) {
return computeFallThrough(parent.getLastChild());
}
 else {
return computeFollowNode(fromNode,parent,cfa);
}
}
 else if (NodeUtil.getCatchBlock(parent) == node) {
if (NodeUtil.hasFinally(parent)) {
return computeFallThrough(node.getNext());
}
 else {
return computeFollowNode(fromNode,parent,cfa);
}
}
 else if (parent.getLastChild() == node) {
if (cfa != null) {
for (Node finallyNode : cfa.finallyMap.get(parent)) {
  cfa.createEdge(fromNode,Branch.ON_EX,finallyNode);
}
}
return computeFollowNode(fromNode,parent,cfa);
}
}
Node nextSibling=node.getNext();
while (nextSibling != null && nextSibling.isFunction()) {
nextSibling=nextSibling.getNext();
}
if (nextSibling != null) {
return computeFallThrough(nextSibling);
}
 else {
return computeFollowNode(fromNode,parent,cfa);
}
}
