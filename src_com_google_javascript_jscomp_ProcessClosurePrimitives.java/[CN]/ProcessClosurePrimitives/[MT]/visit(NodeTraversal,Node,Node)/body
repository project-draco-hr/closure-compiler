{
switch (n.getType()) {
case Token.CALL:
    boolean isExpr=parent.getType() == Token.EXPR_RESULT;
  Node left=n.getFirstChild();
if (left.getType() == Token.GETPROP) {
  Node name=left.getFirstChild();
  if (name.getType() == Token.NAME && GOOG.equals(name.getString())) {
    String methodName=name.getNext().getString();
    if ("base".equals(methodName)) {
      processBaseClassCall(t,n);
    }
 else     if (!isExpr) {
      break;
    }
 else     if ("require".equals(methodName)) {
      processRequireCall(t,n,parent);
    }
 else     if ("provide".equals(methodName)) {
      processProvideCall(t,n,parent);
    }
 else     if ("exportSymbol".equals(methodName)) {
      Node arg=left.getNext();
      if (arg.getType() == Token.STRING) {
        int dot=arg.getString().indexOf('.');
        if (dot == -1) {
          exportedVariables.add(arg.getString());
        }
 else {
          exportedVariables.add(arg.getString().substring(0,dot));
        }
      }
    }
 else     if ("addDependency".equals(methodName)) {
      CodingConvention convention=compiler.getCodingConvention();
      List<String> typeDecls=convention.identifyTypeDeclarationCall(n);
      if (typeDecls != null) {
        for (        String typeDecl : typeDecls) {
          compiler.getTypeRegistry().forwardDeclareType(typeDecl);
        }
      }
      parent.replaceChild(n,Node.newNumber(0));
      compiler.reportCodeChange();
    }
 else     if ("setCssNameMapping".equals(methodName)) {
      processSetCssNameMapping(t,n,parent);
    }
  }
}
break;
case Token.ASSIGN:
case Token.NAME:
handleCandidateProvideDefinition(t,n,parent);
break;
case Token.FUNCTION:
if (t.inGlobalScope() && !NodeUtil.isFunctionAnonymous(n)) {
String name=n.getFirstChild().getString();
ProvidedName pn=providedNames.get(name);
if (pn != null) {
compiler.report(JSError.make(t,n,FUNCTION_NAMESPACE_ERROR,name));
}
}
break;
case Token.NEW:
trySimplifyNewDate(t,n,parent);
break;
case Token.GETPROP:
if (n.getFirstChild().getType() == Token.NAME && parent.getType() != Token.CALL && parent.getType() != Token.ASSIGN && "goog.base".equals(n.getQualifiedName())) {
reportBadBaseClassUse(t,n,"May only be called directly.");
}
break;
}
}
