{
switch (n.getType()) {
case Token.CALL:
    boolean isExpr=parent.getType() == Token.EXPR_RESULT;
  Node left=n.getFirstChild();
if (left.getType() == Token.GETPROP) {
  Node name=left.getFirstChild();
  if (name.getType() == Token.NAME && GOOG.equals(name.getString())) {
    String methodName=name.getNext().getString();
    if ("base".equals(methodName)) {
      processBaseClassCall(t,n);
    }
 else     if (!isExpr) {
      break;
    }
 else     if ("require".equals(methodName)) {
      Node arg=left.getNext();
      if (verifyArgument(t,left,arg)) {
        String ns=arg.getString();
        ProvidedName provided=providedNames.get(ns);
        if (provided == null || !provided.isExplicitlyProvided()) {
          unrecognizedRequires.add(new UnrecognizedRequire(n,ns,t.getSourceName()));
        }
 else {
          JSModule module=t.getModule();
          if (module != provided.firstModule && !compiler.getModuleGraph().dependsOn(module,provided.firstModule)) {
            compiler.report(JSError.make(t,n,XMODULE_REQUIRE_ERROR,ns,provided.firstModule.getName(),module.getName()));
          }
        }
        if (provided != null || requiresLevel.isOn()) {
          parent.getParent().removeChild(parent);
          compiler.reportCodeChange();
        }
      }
    }
 else     if ("provide".equals(methodName)) {
      Node arg=left.getNext();
      if (verifyProvide(t,left,arg)) {
        String ns=arg.getString();
        if (providedNames.containsKey(ns)) {
          ProvidedName previouslyProvided=providedNames.get(ns);
          if (!previouslyProvided.isExplicitlyProvided()) {
            previouslyProvided.addProvide(parent,t.getModule(),true);
          }
 else {
            compiler.report(JSError.make(t,n,DUPLICATE_NAMESPACE_ERROR,ns));
          }
        }
 else {
          registerAnyProvidedPrefixes(ns,parent,t.getModule());
          providedNames.put(ns,new ProvidedName(ns,parent,t.getModule(),true));
        }
      }
    }
 else     if ("exportSymbol".equals(methodName)) {
      Node arg=left.getNext();
      if (arg.getType() == Token.STRING) {
        int dot=arg.getString().indexOf('.');
        if (dot == -1) {
          exportedVariables.add(arg.getString());
        }
 else {
          exportedVariables.add(arg.getString().substring(0,dot));
        }
      }
    }
 else     if ("addDependency".equals(methodName)) {
      CodingConvention convention=compiler.getCodingConvention();
      List<String> typeDecls=convention.identifyTypeDeclarationCall(n);
      if (typeDecls != null) {
        for (        String typeDecl : typeDecls) {
          compiler.getTypeRegistry().forwardDeclareType(typeDecl);
        }
      }
      parent.replaceChild(n,Node.newNumber(0));
      compiler.reportCodeChange();
    }
 else     if ("setCssNameMapping".equals(methodName)) {
      processSetCssNameMapping(t,n,parent);
    }
  }
}
break;
case Token.ASSIGN:
if (t.inGlobalScope() && parent.getType() == Token.EXPR_RESULT) {
Node nameNode=n.getFirstChild();
String name=nameNode.getQualifiedName();
if (name != null) {
if (parent.getBooleanProp(Node.IS_NAMESPACE)) {
  processProvideFromPreviousPass(t,name,parent);
}
 else {
  ProvidedName pn=providedNames.get(name);
  if (pn != null) {
    pn.addDefinition(parent);
  }
}
}
}
break;
case Token.NAME:
if (t.inGlobalScope() && parent.getType() == Token.VAR) {
String name=n.getString();
if (parent.getBooleanProp(Node.IS_NAMESPACE)) {
processProvideFromPreviousPass(t,name,parent);
}
 else {
ProvidedName pn=providedNames.get(name);
if (pn != null) {
pn.addDefinition(parent);
}
}
}
break;
case Token.FUNCTION:
if (t.inGlobalScope() && !NodeUtil.isFunctionAnonymous(n)) {
String name=n.getFirstChild().getString();
ProvidedName pn=providedNames.get(name);
if (pn != null) {
compiler.report(JSError.make(t,n,FUNCTION_NAMESPACE_ERROR,name));
}
}
break;
case Token.NEW:
trySimplifyNewDate(t,n,parent);
break;
case Token.GETPROP:
if (n.getFirstChild().getType() == Token.NAME && parent.getType() != Token.CALL && parent.getType() != Token.ASSIGN && "goog.base".equals(n.getQualifiedName())) {
reportBadBaseClassUse(t,n,"May only be called directly.");
}
break;
}
}
