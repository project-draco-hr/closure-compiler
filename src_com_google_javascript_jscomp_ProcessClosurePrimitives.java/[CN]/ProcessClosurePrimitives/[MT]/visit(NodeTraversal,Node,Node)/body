{
switch (n.getType()) {
case Token.CALL:
    boolean isExpr=parent.isExprResult();
  Node left=n.getFirstChild();
if (left.isGetProp()) {
  Node name=left.getFirstChild();
  if (name.isName() && GOOG.equals(name.getString())) {
    String methodName=name.getNext().getString();
    if ("base".equals(methodName)) {
      processBaseClassCall(t,n);
    }
 else     if (!isExpr) {
      break;
    }
 else     if ("define".equals(methodName)) {
      processDefineCall(t,n,parent);
    }
 else     if ("require".equals(methodName)) {
      processRequireCall(t,n,parent);
    }
 else     if ("provide".equals(methodName)) {
      processProvideCall(t,n,parent);
    }
 else     if ("exportSymbol".equals(methodName)) {
      Node arg=left.getNext();
      if (arg.isString()) {
        int dot=arg.getString().indexOf('.');
        if (dot == -1) {
          exportedVariables.add(arg.getString());
        }
 else {
          exportedVariables.add(arg.getString().substring(0,dot));
        }
      }
    }
 else     if ("addDependency".equals(methodName)) {
      CodingConvention convention=compiler.getCodingConvention();
      List<String> typeDecls=convention.identifyTypeDeclarationCall(n);
      if (typeDecls != null) {
        for (        String typeDecl : typeDecls) {
          compiler.getTypeRegistry().forwardDeclareType(typeDecl);
        }
      }
      parent.replaceChild(n,IR.number(0));
      compiler.reportCodeChange();
    }
 else     if ("setCssNameMapping".equals(methodName)) {
      processSetCssNameMapping(t,n,parent);
    }
  }
}
break;
case Token.ASSIGN:
case Token.NAME:
handleCandidateProvideDefinition(t,n,parent);
break;
case Token.EXPR_RESULT:
handleTypedefDefinition(t,n);
break;
case Token.FUNCTION:
if (t.inGlobalScope() && !NodeUtil.isFunctionExpression(n)) {
String name=n.getFirstChild().getString();
ProvidedName pn=providedNames.get(name);
if (pn != null) {
compiler.report(t.makeError(n,FUNCTION_NAMESPACE_ERROR,name));
}
}
break;
case Token.GETPROP:
if (n.getFirstChild().isName() && !parent.isCall() && !parent.isAssign()&& "goog.base".equals(n.getQualifiedName())) {
reportBadBaseClassUse(t,n,"May only be called directly.");
}
break;
}
}
