{
  Preconditions.checkNotNull(n);
switch (n.getType()) {
case Token.LC:
{
      Map<String,JSType> fields=Maps.newHashMap();
      for (Node fieldTypeNode=n.getFirstChild().getFirstChild(); fieldTypeNode != null; fieldTypeNode=fieldTypeNode.getNext()) {
        Preconditions.checkState(fieldTypeNode.getType() == Token.COLON);
        Node fieldNameNode=fieldTypeNode.getFirstChild();
        String fieldName=fieldNameNode.getString();
        if (fieldName.startsWith("'") || fieldName.startsWith("\"")) {
          fieldName=fieldName.substring(1,fieldName.length() - 1);
        }
        JSType fieldType=getTypeFromNode(fieldTypeNode.getLastChild(),registry);
        fields.put(fieldName,fieldType);
      }
      return JSType.fromObjectType(ObjectType.fromProperties(fields));
    }
case Token.EMPTY:
  return JSType.UNKNOWN;
case Token.STRING:
String typeName=n.getString();
if (typeName.equals("boolean")) {
return JSType.BOOLEAN;
}
 else if (typeName.equals("null")) {
return JSType.NULL;
}
 else if (typeName.equals("number")) {
return JSType.NUMBER;
}
 else if (typeName.equals("string")) {
return JSType.STRING;
}
 else if (typeName.equals("undefined")) {
return JSType.UNDEFINED;
}
 else {
JSType namedType=registry.getNamedTypeByName(typeName);
if (namedType != null) {
  return namedType;
}
throw new UnknownTypeException("Unhandled type: " + typeName);
}
case Token.PIPE:
{
JSType union=JSType.BOTTOM;
for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
union=JSType.join(union,getTypeFromNode(child,registry));
}
return union;
}
case Token.BANG:
{
return getTypeFromNode(n.getFirstChild(),registry).removeType(JSType.NULL);
}
case Token.QMARK:
{
Node child=n.getFirstChild();
if (child == null) {
return JSType.UNKNOWN;
}
 else {
return JSType.join(JSType.NULL,getTypeFromNode(child,registry));
}
}
case Token.STAR:
return JSType.TOP;
case Token.FUNCTION:
{
FunctionTypeBuilder builder=new FunctionTypeBuilder();
Node child=n.getFirstChild();
if (child.getType() == Token.PARAM_LIST) {
for (Node arg=child.getFirstChild(); arg != null; arg=arg.getNext()) {
try {
switch (arg.getType()) {
case Token.EQUALS:
builder.addOptFormal(getTypeFromNode(arg.getFirstChild(),registry));
break;
case Token.ELLIPSIS:
builder.addRestFormals(getTypeFromNode(arg.getFirstChild(),registry));
break;
default :
builder.addReqFormal(getTypeFromNode(arg,registry));
break;
}
}
 catch (IllegalStateException e) {
warn("Wrong parameter order: required parameters are first, " + "then optional, then varargs",n);
}
}
child=child.getNext();
}
builder.addRetType(getTypeFromNode(child,registry));
return builder.buildType();
}
default :
throw new IllegalArgumentException("Unsupported type exp: " + Token.name(n.getType()) + " "+ n.toStringTree());
}
}
