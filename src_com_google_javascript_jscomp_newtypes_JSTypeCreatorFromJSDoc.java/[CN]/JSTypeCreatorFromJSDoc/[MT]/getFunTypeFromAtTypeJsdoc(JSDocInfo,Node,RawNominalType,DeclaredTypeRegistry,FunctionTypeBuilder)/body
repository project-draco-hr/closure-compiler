{
  Preconditions.checkArgument(funNode.isFunction());
  Node childJsdoc=jsdoc.getType().getRoot().getFirstChild();
  Node param=funNode.getFirstChild().getNext().getFirstChild();
  Node paramType;
  boolean warnedForMissingTypes=false;
  boolean warnedForInlineJsdoc=false;
  ImmutableList<String> typeParameters=ownerType == null ? ImmutableList.<String>of() : ownerType.getTypeParameters();
  if (childJsdoc.getType() == Token.THIS) {
    if (ownerType == null) {
      builder.addReceiverType(getNominalType(childJsdoc.getFirstChild(),registry,typeParameters));
    }
    childJsdoc=childJsdoc.getNext();
  }
 else   if (childJsdoc.getType() == Token.NEW) {
    builder.addNominalType(getNominalType(childJsdoc.getFirstChild(),registry,typeParameters));
    childJsdoc=childJsdoc.getNext();
  }
  if (childJsdoc.getType() == Token.PARAM_LIST) {
    paramType=childJsdoc.getFirstChild();
    childJsdoc=childJsdoc.getNext();
  }
 else {
    paramType=null;
  }
  while (param != null) {
    if (paramType == null) {
      if (!warnedForMissingTypes) {
        warn("The function has more formal parameters than the types " + "declared in the JSDoc",funNode);
        warnedForMissingTypes=true;
      }
      builder.addOptFormal(JSType.UNKNOWN);
    }
 else {
      if (!warnedForInlineJsdoc && param.getJSDocInfo() != null) {
        warn("The function cannot have both an @type jsdoc and inline " + "jsdocs. Ignoring inline jsdocs.",param);
        warnedForInlineJsdoc=true;
      }
switch (paramType.getType()) {
case Token.EQUALS:
        builder.addOptFormal(getTypeFromNode(paramType.getFirstChild(),registry,typeParameters));
      break;
case Token.ELLIPSIS:
    if (!warnedForMissingTypes) {
      warn("The function has more formal parameters than the types " + "declared in the JSDoc",funNode);
      warnedForMissingTypes=true;
      builder.addOptFormal(JSType.UNKNOWN);
    }
  break;
default :
builder.addReqFormal(getTypeFromNode(paramType,registry,typeParameters));
break;
}
paramType=paramType.getNext();
}
param=param.getNext();
}
if (paramType != null) {
if (paramType.getType() == Token.ELLIPSIS) {
builder.addRestFormals(getTypeFromNode(paramType.getFirstChild(),registry,typeParameters));
}
 else {
warn("The function has fewer formal parameters than the types " + "declared in the JSDoc",funNode);
}
}
if (!warnedForInlineJsdoc && funNode.getFirstChild().getJSDocInfo() != null) {
warn("The function cannot have both an @type jsdoc and inline " + "jsdocs. Ignoring the inline return jsdoc.",funNode);
}
if (jsdoc.getReturnType() != null) {
warn("The function cannot have both an @type jsdoc and @return " + "jsdoc. Ignoring @return jsdoc.",funNode);
}
if (funNode.getParent().isSetterDef()) {
if (childJsdoc != null) {
warn("Cannot declare a return type on a setter",funNode);
}
builder.addRetType(JSType.UNDEFINED);
}
 else {
builder.addRetType(getTypeFromNode(childJsdoc,registry,typeParameters));
}
return builder.buildDeclaration();
}
