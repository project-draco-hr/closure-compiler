{
  Preconditions.checkNotNull(n);
  Preconditions.checkNotNull(typeParameters);
switch (n.getType()) {
case Token.LC:
    return getRecordTypeHelper(n,registry,typeParameters);
case Token.EMPTY:
  return JSType.UNKNOWN;
case Token.VOID:
return JSType.UNDEFINED;
case Token.LB:
warn("The [] type syntax is no longer supported." + " Please use Array.<T> instead.",n);
return JSType.UNKNOWN;
case Token.STRING:
return getNamedTypeHelper(n,registry,typeParameters);
case Token.PIPE:
{
JSType union=JSType.BOTTOM;
for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
JSType nextType=getTypeFromCommentHelper(child,registry,typeParameters);
if (nextType.isUnknown()) {
warn("This union type is equivalent to '?'.",n);
return JSType.UNKNOWN;
}
union=JSType.join(union,nextType);
}
return union;
}
case Token.BANG:
{
JSType nullableType=getTypeFromCommentHelper(n.getFirstChild(),registry,typeParameters);
if (nullableType.isTypeVariable()) {
warn("Cannot use ! to restrict type variable type.\n" + "Prefer to make type argument non-nullable and add " + "null explicitly where needed (e.g. through ?T or T|null)",n);
}
return nullableType.removeType(JSType.NULL);
}
case Token.QMARK:
{
Node child=n.getFirstChild();
if (child == null) {
return JSType.UNKNOWN;
}
 else {
return JSType.join(JSType.NULL,getTypeFromCommentHelper(child,registry,typeParameters));
}
}
case Token.STAR:
return JSType.TOP;
case Token.FUNCTION:
return getFunTypeHelper(n,null,registry,typeParameters);
default :
throw new IllegalArgumentException("Unsupported type exp: " + Token.name(n.getType()) + " "+ n.toStringTree());
}
}
