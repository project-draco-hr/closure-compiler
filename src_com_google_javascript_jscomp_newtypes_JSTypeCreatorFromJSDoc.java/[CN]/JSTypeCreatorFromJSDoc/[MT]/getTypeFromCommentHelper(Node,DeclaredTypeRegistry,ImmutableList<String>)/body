{
  Preconditions.checkNotNull(n);
  if (typeParameters == null) {
    typeParameters=ImmutableList.of();
  }
switch (n.getType()) {
case Token.LC:
    return getRecordTypeHelper(n,registry,typeParameters);
case Token.EMPTY:
  return JSType.UNKNOWN;
case Token.VOID:
return JSType.UNDEFINED;
case Token.LB:
warnings.add(JSError.make(n,BAD_ARRAY_TYPE_SYNTAX));
return JSType.UNKNOWN;
case Token.STRING:
return getNamedTypeHelper(n,registry,typeParameters);
case Token.PIPE:
{
JSType union=JSType.BOTTOM;
for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
JSType nextType=getTypeFromCommentHelper(child,registry,typeParameters);
if (nextType.isUnknown()) {
warnings.add(JSError.make(n,UNION_WITH_UNKNOWN));
return JSType.UNKNOWN;
}
JSType nextUnion=JSType.join(union,nextType);
if (nextUnion.isBottom()) {
warnings.add(JSError.make(n,UNION_IS_UNINHABITABLE,nextType.toString(),union.toString()));
return JSType.UNKNOWN;
}
union=nextUnion;
}
return union;
}
case Token.BANG:
{
JSType nullableType=getTypeFromCommentHelper(n.getFirstChild(),registry,typeParameters);
if (nullableType.isTypeVariable()) {
warnings.add(JSError.make(n,CANNOT_MAKE_TYPEVAR_NON_NULL));
}
return nullableType.removeType(JSType.NULL);
}
case Token.QMARK:
{
Node child=n.getFirstChild();
if (child == null) {
return JSType.UNKNOWN;
}
 else {
return JSType.join(JSType.NULL,getTypeFromCommentHelper(child,registry,typeParameters));
}
}
case Token.STAR:
return JSType.TOP;
case Token.FUNCTION:
return getFunTypeHelper(n,registry,typeParameters);
default :
throw new IllegalArgumentException("Unsupported type exp: " + Token.name(n.getType()) + " "+ n.toStringTree());
}
}
