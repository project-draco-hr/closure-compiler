{
  Node result=n;
switch (n.getType()) {
case Token.HOOK:
    Node trueNode=trySimpilifyUnusedResult(n.getFirstChild().getNext());
  Node falseNode=trySimpilifyUnusedResult(n.getLastChild());
if (trueNode == null && falseNode != null) {
  n.setType(Token.OR);
  Preconditions.checkState(n.getChildCount() == 2);
}
 else if (trueNode != null && falseNode == null) {
  n.setType(Token.AND);
  Preconditions.checkState(n.getChildCount() == 2);
}
 else if (trueNode == null && falseNode == null) {
  result=trySimpilifyUnusedResult(n.getFirstChild());
}
 else {
  result=n;
}
break;
case Token.AND:
case Token.OR:
Node conditionalResultNode=trySimpilifyUnusedResult(n.getLastChild());
if (conditionalResultNode == null) {
Preconditions.checkState(n.hasOneChild());
result=trySimpilifyUnusedResult(n.getFirstChild());
}
break;
case Token.FUNCTION:
result=null;
break;
case Token.COMMA:
Node left=trySimpilifyUnusedResult(n.getFirstChild());
Node right=trySimpilifyUnusedResult(n.getLastChild());
if (left == null && right == null) {
result=null;
}
 else if (left == null) {
result=right;
}
 else if (right == null) {
result=left;
}
 else {
result=n;
}
break;
default :
if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {
Node resultList=null;
for (Node next, c=n.getFirstChild(); c != null; c=next) {
next=c.getNext();
c=trySimpilifyUnusedResult(c);
if (c != null) {
c.detachFromParent();
if (resultList == null) {
resultList=c;
}
 else {
resultList=new Node(Token.COMMA,resultList,c).copyInformationFrom(c);
}
}
}
result=resultList;
}
}
if (n != result) {
Node parent=n.getParent();
if (result == null) {
if (removeUnused) {
parent.removeChild(n);
}
 else {
result=new Node(Token.EMPTY).copyInformationFrom(n);
parent.replaceChild(n,result);
}
}
 else {
if (result.getParent() != null) {
result.detachFromParent();
}
n.getParent().replaceChild(n,result);
}
reportCodeChange();
}
return result;
}
