{
  Node parent=n.getParent();
  int type=n.getType();
  Node cond=n.getFirstChild();
  Node thenBody=cond.getNext();
  Node elseBody=thenBody.getNext();
  boolean changes=false;
  if (type == Token.IF) {
    if (elseBody != null && !mayHaveSideEffects(elseBody)) {
      n.removeChild(elseBody);
      elseBody=null;
      reportCodeChange();
      changes=true;
    }
    if (!mayHaveSideEffects(thenBody) && elseBody != null) {
      n.removeChild(elseBody);
      n.replaceChild(thenBody,elseBody);
      Node notCond=new Node(Token.NOT);
      n.replaceChild(cond,notCond);
      notCond.addChildToFront(cond);
      cond=notCond;
      thenBody=cond.getNext();
      elseBody=null;
      reportCodeChange();
      changes=true;
    }
    if (!mayHaveSideEffects(thenBody) && elseBody == null) {
      if (mayHaveSideEffects(cond)) {
        n.removeChild(cond);
        Node replacement=NodeUtil.newExpr(cond);
        parent.replaceChild(n,replacement);
        reportCodeChange();
        return replacement;
      }
 else {
        NodeUtil.removeChild(parent,n);
        reportCodeChange();
        return null;
      }
    }
  }
 else {
    Preconditions.checkState(type == Token.HOOK);
    if (NodeUtil.isExpressionNode(parent)) {
      if (!mayHaveSideEffects(thenBody)) {
        Node ifNode=new Node(Token.IF);
        if (cond.getType() == Token.NOT) {
          Node expr=cond.getFirstChild();
          cond.removeChild(expr);
          ifNode.addChildToBack(expr);
        }
 else {
          Node not=new Node(Token.NOT).copyInformationFrom(cond);
          n.removeChild(cond);
          not.addChildToBack(cond);
          ifNode.addChildToBack(not);
        }
        n.removeChild(elseBody);
        ifNode.addChildToBack(new Node(Token.BLOCK,NodeUtil.newExpr(elseBody)).copyInformationFrom(elseBody));
        parent.getParent().replaceChild(parent,ifNode);
        reportCodeChange();
        return ifNode;
      }
 else       if (!mayHaveSideEffects(elseBody)) {
        Node ifNode=new Node(Token.IF);
        n.removeChild(cond);
        ifNode.addChildToBack(cond);
        n.removeChild(thenBody);
        ifNode.addChildToBack(new Node(Token.BLOCK,NodeUtil.newExpr(thenBody)).copyInformationFrom(thenBody));
        parent.getParent().replaceChild(parent,ifNode);
        reportCodeChange();
        return ifNode;
      }
    }
  }
  TernaryValue condValue=NodeUtil.getExpressionBooleanValue(cond);
  if (condValue == TernaryValue.UNKNOWN) {
    return n;
  }
  if (mayHaveSideEffects(cond)) {
    if (n.getType() == Token.HOOK) {
      Node replacement=new Node(Token.BLOCK).copyInformationFrom(n);
      n.detachChildren();
      replacement.addChildToFront(new Node(Token.EXPR_RESULT,cond).copyInformationFrom(cond));
      Node branchToKeep=condValue.toBoolean(true) ? thenBody : elseBody;
      replacement.addChildToBack(NodeUtil.newExpr(branchToKeep).copyInformationFrom(branchToKeep));
      parent.getParent().replaceChild(parent,replacement);
      reportCodeChange();
      return replacement;
    }
    Preconditions.checkState(n.getType() == Token.IF);
    boolean newConditionValue=condValue == TernaryValue.TRUE;
    if (!newConditionValue && elseBody == null) {
      elseBody=new Node(Token.BLOCK).copyInformationFrom(n);
      n.addChildToBack(elseBody);
    }
    Node newCond=new Node(newConditionValue ? Token.TRUE : Token.FALSE);
    n.replaceChild(cond,newCond);
    Node branchToKeep=newConditionValue ? thenBody : elseBody;
    branchToKeep.addChildToFront(new Node(Token.EXPR_RESULT,cond).copyInformationFrom(cond));
    reportCodeChange();
    cond=newCond;
  }
  boolean condTrue=condValue.toBoolean(true);
  if (n.getChildCount() == 2) {
    Preconditions.checkState(type == Token.IF);
    if (condTrue) {
      Node thenStmt=n.getFirstChild().getNext();
      n.removeChild(thenStmt);
      parent.replaceChild(n,thenStmt);
      reportCodeChange();
      return thenStmt;
    }
 else {
      NodeUtil.redeclareVarsInsideBranch(n);
      NodeUtil.removeChild(parent,n);
      reportCodeChange();
      return null;
    }
  }
 else {
    Node firstBranch=n.getFirstChild().getNext();
    Node secondBranch=firstBranch.getNext();
    Node branch=condTrue ? firstBranch : secondBranch;
    Node notBranch=condTrue ? secondBranch : firstBranch;
    NodeUtil.redeclareVarsInsideBranch(notBranch);
    n.removeChild(branch);
    parent.replaceChild(n,branch);
    reportCodeChange();
    return branch;
  }
}
