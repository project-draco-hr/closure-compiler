{
  Preconditions.checkArgument(externs.isSyntheticBlock());
  Preconditions.checkArgument(root.isSyntheticBlock());
  globalScope=new Scope(root,null,new ArrayList<String>(),null);
  scopes.addFirst(globalScope);
  CollectNamedTypes rootCnt=new CollectNamedTypes(globalScope);
  new NodeTraversal(compiler,rootCnt).traverse(externs);
  new NodeTraversal(compiler,rootCnt).traverse(root);
  ProcessScope rootPs=new ProcessScope(globalScope);
  new NodeTraversal(compiler,rootPs).traverse(externs);
  new NodeTraversal(compiler,rootPs).traverse(root);
  rootPs.finishProcessingScope();
  while (!scopeWorkset.isEmpty()) {
    Scope s=scopeWorkset.removeFirst();
    Node scopeBody=s.getBody();
    new NodeTraversal(compiler,new CollectNamedTypes(s)).traverse(scopeBody);
    ProcessScope ps=new ProcessScope(s);
    new NodeTraversal(compiler,ps).traverse(scopeBody);
    ps.finishProcessingScope();
  }
  reportInheritanceErrors();
  nominaltypesByNode=null;
  propertyDefs=null;
  for (  Scope s : scopes) {
    s.finalizeScope();
  }
  Map<Node,String> unknownTypes=typeParser.getUnknownTypesMap();
  for (  Node unknownTypeNode : unknownTypes.keySet()) {
    warnings.add(JSError.make(unknownTypeNode,UNRECOGNIZED_TYPE_NAME,unknownTypes.get(unknownTypeNode)));
  }
  for (  String warningText : typeParser.getWarnings()) {
    warnings.add(JSError.make(root,RhinoErrorReporter.BAD_JSDOC_ANNOTATION,warningText));
  }
  compiler.setSymbolTable(this);
}
