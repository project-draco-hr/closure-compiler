{
  Preconditions.checkArgument(externs == null || externs.isSyntheticBlock());
  Preconditions.checkArgument(root.isSyntheticBlock());
  globalScope=new Scope(root,null,ImmutableList.<String>of());
  scopes.add(globalScope);
  CollectNamedTypes rootCnt=new CollectNamedTypes(globalScope);
  if (externs != null) {
    new NodeTraversal(compiler,rootCnt).traverse(externs);
  }
  new NodeTraversal(compiler,rootCnt).traverse(root);
  globalScope.resolveTypedefs(typeParser);
  globalScope.resolveEnums(typeParser);
  for (int i=1; i < scopes.size(); i++) {
    Scope s=scopes.get(i);
    CollectNamedTypes cnt=new CollectNamedTypes(s);
    new NodeTraversal(compiler,cnt).traverse(s.getBody());
    s.resolveTypedefs(typeParser);
    s.resolveEnums(typeParser);
    if (NewTypeInference.measureMem) {
      NewTypeInference.updatePeakMem();
    }
  }
  ProcessScope rootPs=new ProcessScope(globalScope);
  if (externs != null) {
    new NodeTraversal(compiler,rootPs).traverse(externs);
  }
  new NodeTraversal(compiler,rootPs).traverse(root);
  rootPs.finishProcessingScope();
  for (int i=1; i < scopes.size(); i++) {
    Scope s=scopes.get(i);
    ProcessScope ps=new ProcessScope(s);
    new NodeTraversal(compiler,ps).traverse(s.getBody());
    ps.finishProcessingScope();
    if (NewTypeInference.measureMem) {
      NewTypeInference.updatePeakMem();
    }
  }
  reportInheritanceErrors();
  nominaltypesByNode=null;
  propertyDefs=null;
  for (  Scope s : scopes) {
    s.removeTmpData();
  }
  Map<Node,String> unknownTypes=typeParser.getUnknownTypesMap();
  for (  Map.Entry<Node,String> unknownTypeEntry : unknownTypes.entrySet()) {
    warnings.add(JSError.make(unknownTypeEntry.getKey(),UNRECOGNIZED_TYPE_NAME,unknownTypeEntry.getValue()));
  }
  for (  String warningText : typeParser.getWarnings()) {
    warnings.add(JSError.make(root,RhinoErrorReporter.BAD_JSDOC_ANNOTATION,warningText));
  }
  typeParser=null;
  compiler.setSymbolTable(this);
  warnings=null;
  Collections.reverse(scopes);
}
