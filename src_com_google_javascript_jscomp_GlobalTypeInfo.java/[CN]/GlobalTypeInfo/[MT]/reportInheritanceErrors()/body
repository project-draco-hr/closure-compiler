{
  Deque<Node> workset=new LinkedList<>(nominaltypesByNode.keySet());
  int iterations=0;
  final int MAX_ITERATIONS=50000;
  workset_loop:   while (!workset.isEmpty()) {
    Preconditions.checkState(iterations < MAX_ITERATIONS);
    Node funNode=workset.removeFirst();
    RawNominalType rawNominalType=nominaltypesByNode.get(funNode);
    NominalType superClass=rawNominalType.getSuperClass();
    Set<String> nonInheritedPropNames=rawNominalType.getAllOwnProps();
    if (superClass != null && !superClass.isFinalized()) {
      workset.addLast(funNode);
      iterations++;
      continue workset_loop;
    }
    for (    NominalType superInterf : rawNominalType.getInterfaces()) {
      if (!superInterf.isFinalized()) {
        workset.addLast(funNode);
        iterations++;
        continue workset_loop;
      }
    }
    Multimap<String,DeclaredFunctionType> propMethodTypesToProcess=LinkedHashMultimap.create();
    Multimap<String,JSType> propTypesToProcess=LinkedHashMultimap.create();
    if (superClass != null) {
      Preconditions.checkState(superClass.isFinalized());
      for (      String pname : superClass.getAllPropsOfClass()) {
        nonInheritedPropNames.remove(pname);
        checkSuperProperty(rawNominalType,superClass,pname,propMethodTypesToProcess,propTypesToProcess);
      }
    }
    for (    NominalType superInterf : rawNominalType.getInterfaces()) {
      Preconditions.checkState(superInterf.isFinalized());
      for (      String pname : superInterf.getAllPropsOfInterface()) {
        nonInheritedPropNames.remove(pname);
        checkSuperProperty(rawNominalType,superInterf,pname,propMethodTypesToProcess,propTypesToProcess);
      }
    }
    for (    String pname : propMethodTypesToProcess.keySet()) {
      Collection<DeclaredFunctionType> methodTypes=propMethodTypesToProcess.get(pname);
      Preconditions.checkState(!methodTypes.isEmpty());
      PropertyDef localPropDef=propertyDefs.get(rawNominalType,pname);
      DeclaredFunctionType superMethodType=DeclaredFunctionType.meet(methodTypes);
      DeclaredFunctionType updatedMethodType=localPropDef.methodType.withTypeInfoFromSuper(superMethodType);
      localPropDef.updateMethodType(updatedMethodType);
      propTypesToProcess.put(pname,commonTypes.fromFunctionType(updatedMethodType.toFunctionType()));
    }
    add_interface_props:     for (    String pname : propTypesToProcess.keySet()) {
      Collection<JSType> defs=propTypesToProcess.get(pname);
      Preconditions.checkState(!defs.isEmpty());
      JSType resultType=JSType.TOP;
      for (      JSType inheritedType : defs) {
        resultType=JSType.meet(resultType,inheritedType);
        if (!resultType.isBottom()) {
          resultType=inheritedType;
        }
 else {
          warnings.add(JSError.make(funNode,TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,NodeUtil.getFunctionName(funNode),pname,"",""));
          continue add_interface_props;
        }
      }
      rawNominalType.addProtoProperty(pname,null,resultType,false);
    }
    for (    String pname : nonInheritedPropNames) {
      Node defSite=propertyDefs.get(rawNominalType,pname).defSite;
      JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(defSite);
      if (jsdoc != null && jsdoc.isOverride()) {
        warnings.add(JSError.make(defSite,TypeCheck.UNKNOWN_OVERRIDE,pname,rawNominalType.getName()));
      }
    }
    rawNominalType.finalizeNominalType();
  }
}
