{
  Deque<Node> workset=Lists.newLinkedList(nominaltypesByNode.keySet());
  int iterations=0;
  final int MAX_ITERATIONS=50000;
  workset_loop:   while (!workset.isEmpty()) {
    Preconditions.checkState(iterations < MAX_ITERATIONS);
    Node funNode=workset.removeFirst();
    RawNominalType rawNominalType=nominaltypesByNode.get(funNode);
    NominalType superClass=rawNominalType.getSuperClass();
    if (superClass != null && !superClass.isFinalized()) {
      workset.addLast(funNode);
      iterations++;
      continue workset_loop;
    }
    for (    NominalType superInterf : rawNominalType.getInterfaces()) {
      if (!superInterf.isFinalized()) {
        workset.addLast(funNode);
        iterations++;
        continue workset_loop;
      }
    }
    Multimap<String,DeclaredFunctionType> propMethodTypesToProcess=HashMultimap.create();
    Multimap<String,JSType> propTypesToProcess=HashMultimap.create();
    if (superClass != null) {
      Preconditions.checkState(superClass.isFinalized());
      for (      String pname : superClass.getAllPropsOfClass()) {
        checkSuperProperty(rawNominalType,superClass,pname,propMethodTypesToProcess,propTypesToProcess);
      }
    }
    for (    NominalType superInterf : rawNominalType.getInterfaces()) {
      Preconditions.checkState(superInterf.isFinalized());
      for (      String pname : superInterf.getAllPropsOfInterface()) {
        checkSuperProperty(rawNominalType,superInterf,pname,propMethodTypesToProcess,propTypesToProcess);
      }
    }
    for (    String pname : propMethodTypesToProcess.keySet()) {
      Collection<DeclaredFunctionType> methodTypes=propMethodTypesToProcess.get(pname);
      Preconditions.checkState(!methodTypes.isEmpty());
      PropertyDef localPropDef=propertyDefs.get(rawNominalType.getId(),pname);
      DeclaredFunctionType propDeclType=localPropDef.methodScope.getDeclaredType();
      DeclaredFunctionType superMethodType=DeclaredFunctionType.meet(methodTypes);
      propDeclType=propDeclType.withTypeInfoFromSuper(superMethodType);
      localPropDef.methodScope.setDeclaredType(propDeclType);
      propTypesToProcess.put(pname,JSType.fromFunctionType(propDeclType.toFunctionType()));
    }
    add_interface_props:     for (    String pname : propTypesToProcess.keySet()) {
      Collection<JSType> defs=propTypesToProcess.get(pname);
      Preconditions.checkState(!defs.isEmpty());
      JSType resultType=JSType.TOP;
      for (      JSType inheritedType : defs) {
        if (inheritedType.isSubtypeOf(resultType)) {
          resultType=inheritedType;
        }
 else         if (!resultType.isSubtypeOf(inheritedType)) {
          warnings.add(JSError.make(funNode,TypeCheck.INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,NodeUtil.getFunctionName(funNode),pname,"",""));
          continue add_interface_props;
        }
      }
      rawNominalType.addProtoProperty(pname,resultType);
    }
    rawNominalType.finalizeNominalType();
  }
}
