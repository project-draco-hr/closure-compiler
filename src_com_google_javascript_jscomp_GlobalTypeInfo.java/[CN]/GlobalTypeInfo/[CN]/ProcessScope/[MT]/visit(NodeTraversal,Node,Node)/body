{
switch (n.getType()) {
case Token.FUNCTION:
    Node grandparent=parent.getParent();
  if (grandparent == null || (!isPrototypePropertyDeclaration(grandparent) && !isClassPropertyDeclaration(parent.getFirstChild(),currentScope))) {
    RawNominalType ownerType=maybeGetOwnerType(n,parent);
    visitFunctionLate(n,ownerType);
  }
break;
case Token.NAME:
{
String name=n.getString();
if (name == null || "undefined".equals(name) || parent.isFunction()) {
  return;
}
if (parent.isVar() || parent.isCatch()) {
  visitVar(n,parent);
}
 else if (currentScope.isOuterVarEarly(name)) {
  currentScope.addOuterVar(name);
}
 else if (currentScope.getTypedef(name) != null || !name.equals(currentScope.getName()) && !currentScope.isDefinedLocally(name,false)) {
}
break;
}
case Token.GETPROP:
if (parent.isExprResult() && n.isQualifiedName()) {
visitPropertyDeclaration(n);
}
break;
case Token.ASSIGN:
{
Node lvalue=n.getFirstChild();
if (lvalue.isGetProp() && lvalue.isQualifiedName() && parent.isExprResult()) {
visitPropertyDeclaration(lvalue);
}
break;
}
case Token.CAST:
castTypes.put(n,getDeclaredTypeOfNode(n.getJSDocInfo(),currentScope));
break;
case Token.OBJECTLIT:
visitObjectLit(n,parent);
break;
case Token.CALL:
visitCall(n);
break;
}
}
