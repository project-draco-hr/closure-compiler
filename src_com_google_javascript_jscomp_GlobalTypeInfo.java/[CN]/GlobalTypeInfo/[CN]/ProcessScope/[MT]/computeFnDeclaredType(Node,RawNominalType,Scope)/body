{
  Preconditions.checkArgument(fn.isFunction());
  JSDocInfo fnDoc=NodeUtil.getFunctionJSDocInfo(fn);
  ImmutableList<String> typeParameters=fnDoc == null ? null : fnDoc.getTemplateTypeNames();
  ArrayList<String> formals=Lists.newArrayList();
  for (Node param=NodeUtil.getFunctionParameters(fn).getFirstChild(); param != null; param=param.getNext()) {
    formals.add(param.getQualifiedName());
  }
  FunctionTypeBuilder builder=typeParser.getFunctionType(fnDoc,fn,ownerType,parentScope);
  String functionName=getFunInternalName(fn);
  if (fnDoc != null) {
    NominalType parentClass=null;
    if (fnDoc.hasBaseType()) {
      if (!fnDoc.isConstructor()) {
        warnings.add(JSError.make(fn,EXTENDS_NOT_ON_CTOR_OR_INTERF,functionName));
      }
 else {
        Node docNode=fnDoc.getBaseType().getRootNode();
        if (typeParser.hasKnownType(docNode,ownerType,parentScope,typeParameters)) {
          parentClass=typeParser.getNominalType(docNode,ownerType,parentScope,typeParameters);
          if (parentClass == null) {
            warnings.add(JSError.make(fn,EXTENDS_NON_OBJECT,functionName,docNode.toStringTree()));
          }
 else           if (!parentClass.isClass()) {
            warnings.add(JSError.make(fn,TypeCheck.CONFLICTING_EXTENDED_TYPE,"constructor",functionName));
            parentClass=null;
          }
        }
      }
    }
    RawNominalType rawNominalType=nominaltypesByNode.get(fn);
    if (fnDoc.isConstructor()) {
      if (parentClass != null) {
        if (!rawNominalType.addSuperClass(parentClass)) {
          warnings.add(JSError.make(fn,INHERITANCE_CYCLE,rawNominalType.toString()));
        }
      }
      Set<NominalType> interfaces=Sets.newHashSet(typeParser.getImplementedInterfaces(fnDoc,ownerType,parentScope,typeParameters));
      for (      NominalType interf : interfaces) {
        if (interf.isClass()) {
          warnings.add(JSError.make(fn,TypeCheck.CONFLICTING_IMPLEMENTED_TYPE,functionName));
          interfaces.remove(interf);
        }
      }
      boolean noCycles=rawNominalType.addInterfaces(ImmutableSet.copyOf(interfaces));
      Preconditions.checkState(noCycles);
      builder.addNominalType(NominalType.fromRaw(rawNominalType));
    }
 else     if (fnDoc.isInterface()) {
      if (!NodeUtil.isEmptyBlock(NodeUtil.getFunctionBody(fn))) {
        warnings.add(JSError.make(fn,INTERFACE_WITH_A_BODY));
      }
      ImmutableSet<NominalType> implemented=typeParser.getImplementedInterfaces(fnDoc,ownerType,parentScope,typeParameters);
      if (!implemented.isEmpty()) {
        warnings.add(JSError.make(fn,TypeCheck.CONFLICTING_IMPLEMENTED_TYPE,functionName));
      }
      Set<NominalType> interfaces=Sets.newHashSet(typeParser.getExtendedInterfaces(fnDoc,ownerType,parentScope,typeParameters));
      for (      NominalType interf : interfaces) {
        if (interf.isClass()) {
          warnings.add(JSError.make(fn,TypeCheck.CONFLICTING_EXTENDED_TYPE,"interface",functionName));
          interfaces.remove(interf);
        }
      }
      boolean noCycles=rawNominalType.addInterfaces(ImmutableSet.copyOf(interfaces));
      if (!noCycles) {
        warnings.add(JSError.make(fn,INHERITANCE_CYCLE,rawNominalType.toString()));
      }
      builder.addNominalType(NominalType.fromRaw(rawNominalType));
    }
  }
  if (NodeUtil.isPrototypeMethod(fn)) {
    Node lhsNode=fn.getParent().getFirstChild();
    String className=NodeUtil.getPrototypeClassName(lhsNode).getQualifiedName();
    builder.addReceiverType(parentScope.getScope(className).getDeclaredType().getNominalType());
  }
  return new Scope(fn,parentScope,formals,builder.buildDeclaration());
}
