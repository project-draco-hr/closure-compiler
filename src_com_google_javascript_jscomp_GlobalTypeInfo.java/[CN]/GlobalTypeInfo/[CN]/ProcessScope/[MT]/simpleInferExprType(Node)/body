{
switch (n.getType()) {
case Token.REGEXP:
    return commonTypes.getRegexpType();
case Token.ARRAYLIT:
{
    if (!n.hasChildren()) {
      return commonTypes.getArrayInstance();
    }
    Node child=n.getFirstChild();
    JSType arrayType=simpleInferExprType(child);
    if (arrayType == null) {
      return null;
    }
    while (null != (child=child.getNext())) {
      if (!arrayType.equals(simpleInferExprType(child))) {
        return null;
      }
    }
    return commonTypes.getArrayInstance(arrayType);
  }
case Token.TRUE:
return JSType.TRUE_TYPE;
case Token.FALSE:
return JSType.FALSE_TYPE;
case Token.THIS:
return this.currentScope.getDeclaredTypeOf("this");
case Token.NAME:
return simpleInferDeclaration(this.currentScope.getDeclaration(n.getString(),false));
case Token.OBJECTLIT:
{
JSType objLitType=JSType.TOP_OBJECT;
for (Node prop : n.children()) {
JSType propType=simpleInferExprType(prop.getFirstChild());
if (propType == null) {
return null;
}
objLitType=objLitType.withProperty(new QualifiedName(NodeUtil.getObjectLitKeyName(prop)),propType);
}
return objLitType;
}
case Token.GETPROP:
return simpleInferGetpropType(n);
case Token.COMMA:
case Token.ASSIGN:
return simpleInferExprType(n.getLastChild());
case Token.CALL:
case Token.NEW:
return simpleInferCallNewType(n);
default :
switch (NodeUtil.getKnownValueType(n)) {
case NULL:
return JSType.NULL;
case VOID:
return JSType.UNDEFINED;
case NUMBER:
return JSType.NUMBER;
case STRING:
return JSType.STRING;
case BOOLEAN:
return JSType.BOOLEAN;
case UNDETERMINED:
default :
return null;
}
}
}
