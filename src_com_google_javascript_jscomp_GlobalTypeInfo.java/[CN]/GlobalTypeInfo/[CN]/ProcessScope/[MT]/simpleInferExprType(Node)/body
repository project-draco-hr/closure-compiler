{
switch (n.getType()) {
case Token.REGEXP:
    return commonTypes.getRegexpType();
case Token.CAST:
  return castTypes.get(n);
case Token.ARRAYLIT:
{
  if (!n.hasChildren()) {
    return commonTypes.getArrayInstance();
  }
  Node child=n.getFirstChild();
  JSType arrayType=simpleInferExprType(child);
  if (arrayType == null) {
    return null;
  }
  while (null != (child=child.getNext())) {
    if (!arrayType.equals(simpleInferExprType(child))) {
      return null;
    }
  }
  return commonTypes.getArrayInstance(arrayType);
}
case Token.TRUE:
return JSType.TRUE_TYPE;
case Token.FALSE:
return JSType.FALSE_TYPE;
case Token.THIS:
return this.currentScope.getDeclaredTypeOf("this");
case Token.NAME:
return simpleInferDeclaration(this.currentScope.getDeclaration(n.getString(),false));
case Token.OBJECTLIT:
{
JSType objLitType=JSType.TOP_OBJECT;
for (Node prop : n.children()) {
JSType propType=simpleInferExprType(prop.getFirstChild());
if (propType == null) {
return null;
}
objLitType=objLitType.withProperty(new QualifiedName(NodeUtil.getObjectLitKeyName(prop)),propType);
}
return objLitType;
}
case Token.GETPROP:
return simpleInferPropAccessType(n.getFirstChild(),n.getLastChild().getString());
case Token.GETELEM:
return simpleInferGetelemType(n);
case Token.COMMA:
case Token.ASSIGN:
return simpleInferExprType(n.getLastChild());
case Token.CALL:
case Token.NEW:
return simpleInferCallNewType(n);
case Token.AND:
case Token.OR:
return simpleInferAndOrType(n);
case Token.HOOK:
{
JSType lhs=simpleInferExprType(n.getSecondChild());
JSType rhs=simpleInferExprType(n.getLastChild());
return lhs == null || rhs == null ? null : JSType.join(lhs,rhs);
}
default :
switch (NodeUtil.getKnownValueType(n)) {
case NULL:
return JSType.NULL;
case VOID:
return JSType.UNDEFINED;
case NUMBER:
return JSType.NUMBER;
case STRING:
return JSType.STRING;
case BOOLEAN:
return JSType.BOOLEAN;
default :
return null;
}
}
}
