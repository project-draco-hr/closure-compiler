{
switch (n.getType()) {
case Token.AND:
case Token.BLOCK:
case Token.EXPR_RESULT:
case Token.HOOK:
case Token.IF:
case Token.IN:
case Token.PARAM_LIST:
case Token.NUMBER:
case Token.OR:
case Token.THIS:
case Token.TRUE:
case Token.FALSE:
case Token.NULL:
case Token.STRING:
case Token.STRING_KEY:
case Token.SWITCH:
case Token.TRY:
case Token.EMPTY:
    break;
case Token.THROW:
  return true;
case Token.OBJECTLIT:
if (checkForNewObjects) {
  return true;
}
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (checkForStateChangeHelper(c.getFirstChild(),checkForNewObjects,compiler)) {
  return true;
}
}
return false;
case Token.ARRAYLIT:
case Token.REGEXP:
if (checkForNewObjects) {
return true;
}
break;
case Token.VAR:
case Token.NAME:
if (n.getFirstChild() != null) {
return true;
}
break;
case Token.FUNCTION:
return checkForNewObjects || !isFunctionExpression(n);
case Token.NEW:
if (checkForNewObjects) {
return true;
}
if (!constructorCallHasSideEffects(n)) {
break;
}
return true;
case Token.CALL:
if (!functionCallHasSideEffects(n,compiler)) {
break;
}
return true;
default :
if (isSimpleOperatorType(n.getType())) {
break;
}
if (isAssignmentOp(n)) {
Node assignTarget=n.getFirstChild();
if (assignTarget.isName()) {
return true;
}
if (checkForStateChangeHelper(n.getFirstChild(),checkForNewObjects,compiler) || checkForStateChangeHelper(n.getLastChild(),checkForNewObjects,compiler)) {
return true;
}
if (isGet(assignTarget)) {
Node current=assignTarget.getFirstChild();
if (evaluatesToLocalValue(current)) {
return false;
}
while (isGet(current)) {
current=current.getFirstChild();
}
return !isLiteralValue(current,true);
}
 else {
return !isLiteralValue(assignTarget,true);
}
}
return true;
}
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (checkForStateChangeHelper(c,checkForNewObjects,compiler)) {
return true;
}
}
return false;
}
