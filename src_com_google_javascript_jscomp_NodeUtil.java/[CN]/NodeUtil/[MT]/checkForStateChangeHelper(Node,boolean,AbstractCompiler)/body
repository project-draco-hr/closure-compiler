{
switch (n.getType()) {
case Token.AND:
case Token.BLOCK:
case Token.EXPR_RESULT:
case Token.HOOK:
case Token.IF:
case Token.IN:
case Token.LP:
case Token.NUMBER:
case Token.OR:
case Token.THIS:
case Token.TRUE:
case Token.FALSE:
case Token.NULL:
case Token.STRING:
case Token.SWITCH:
case Token.TRY:
case Token.EMPTY:
    break;
case Token.THROW:
  return true;
case Token.OBJECTLIT:
case Token.ARRAYLIT:
case Token.REGEXP:
if (checkForNewObjects) {
  return true;
}
break;
case Token.VAR:
case Token.NAME:
if (n.getFirstChild() != null) {
return true;
}
break;
case Token.FUNCTION:
return checkForNewObjects || !isFunctionExpression(n);
case Token.NEW:
if (checkForNewObjects) {
return true;
}
if (!constructorCallHasSideEffects(n)) {
break;
}
return true;
case Token.CALL:
if (!functionCallHasSideEffects(n,compiler)) {
break;
}
return true;
default :
if (isSimpleOperatorType(n.getType())) {
break;
}
if (isAssignmentOp(n)) {
if (checkForStateChangeHelper(n.getFirstChild(),checkForNewObjects,compiler) || checkForStateChangeHelper(n.getLastChild(),checkForNewObjects,compiler)) {
return true;
}
Node current=n.getFirstChild();
for (; current.getType() == Token.GETPROP || current.getType() == Token.GETELEM; current=current.getFirstChild()) {
}
return !isLiteralValue(current,true);
}
return true;
}
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (checkForStateChangeHelper(c,checkForNewObjects,compiler)) {
return true;
}
}
return false;
}
