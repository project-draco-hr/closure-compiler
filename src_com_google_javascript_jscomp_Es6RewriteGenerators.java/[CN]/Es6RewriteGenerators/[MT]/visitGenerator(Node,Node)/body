{
  Node genBlock=compiler.parseSyntheticCode(Joiner.on('\n').join("{","  return {" + ITER_KEY + ": function() {","    var " + GENERATOR_STATE + " = "+ generatorCaseCount+ ";","    return { next: function() {","      while (1) switch (" + GENERATOR_STATE + ") {","        case " + generatorCaseCount + ":","        default:","          return {done: true};","      }","    }}","  }}","}")).removeFirstChild();
  generatorCaseCount++;
  Node genFunc=IR.function(n.removeFirstChild(),n.removeFirstChild(),genBlock);
  Node originalBody=n.getFirstChild();
  originalBody.addChildToBack(IR.exprResult(IR.assign(IR.name(GENERATOR_STATE),IR.number(-1))));
  Node currentCase=getUnique(genBlock,Token.CASE);
  Node varRoot=getUnique(genBlock,Token.VAR);
  while (originalBody.hasChildren()) {
    Node nextStatement=originalBody.removeFirstChild();
    boolean makeFreshCase;
    if (nextStatement.isExprResult() && nextStatement.getFirstChild().isYield()) {
      visitYieldExprResult(nextStatement,currentCase);
      makeFreshCase=true;
    }
 else     if (nextStatement.isVar()) {
      visitVar(nextStatement,currentCase,varRoot);
      makeFreshCase=false;
    }
 else {
      currentCase.getLastChild().addChildToBack(nextStatement);
      makeFreshCase=false;
    }
    if (makeFreshCase) {
      Node newCase=IR.caseNode(IR.number(generatorCaseCount),IR.block());
      currentCase.getParent().addChildAfter(newCase,currentCase);
      currentCase=newCase;
      generatorCaseCount++;
    }
  }
  parent.replaceChild(n,genFunc);
  parent.useSourceInfoIfMissingFromForTree(parent);
  compiler.reportCodeChange();
}
