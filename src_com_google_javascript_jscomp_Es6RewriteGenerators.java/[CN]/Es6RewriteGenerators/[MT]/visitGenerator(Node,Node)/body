{
  Node genBlock=compiler.parseSyntheticCode(Joiner.on('\n').join("{","  return {" + ITER_KEY + ": function() {","    var " + GENERATOR_STATE + " = "+ generatorCaseCount+ ";","    return { next: function() {","      while (1) switch (" + GENERATOR_STATE + ") {","        case " + generatorCaseCount + ":","        default:","          return {done: true};","      }","    }}","  }}","}")).removeFirstChild();
  generatorCaseCount++;
  Node genFunc=IR.function(n.removeFirstChild(),n.removeFirstChild(),genBlock);
  Node originalBody=n.getFirstChild();
  originalBody.addChildToBack(IR.exprResult(IR.assign(IR.name(GENERATOR_STATE),IR.number(-1))));
  Node currentCase=getUnique(genBlock,Token.CASE);
  Node varRoot=getUnique(genBlock,Token.VAR);
  while (originalBody.hasChildren()) {
    Node nextStatement=originalBody.removeFirstChild();
    boolean advanceCase=translateStatementInOriginalBody(nextStatement,currentCase,originalBody,varRoot);
    if (advanceCase) {
      int caseNumber;
      if (nextStatement.isGeneratorMarker()) {
        caseNumber=(int)nextStatement.getDouble();
      }
 else {
        caseNumber=generatorCaseCount;
        generatorCaseCount++;
      }
      Node newCase=IR.caseNode(IR.number(caseNumber),IR.block());
      currentCase.getParent().addChildAfter(newCase,currentCase);
      currentCase=newCase;
    }
  }
  parent.replaceChild(n,genFunc);
  parent.useSourceInfoIfMissingFromForTree(parent);
  compiler.reportCodeChange();
}
