{
  Node enclosingFunc=NodeUtil.getEnclosingFunction(n);
  if (enclosingFunc == null || !enclosingFunc.isGeneratorFunction() || NodeUtil.isForIn(n)) {
    return;
  }
  Node enclosingBlock=NodeUtil.getEnclosingType(n,Token.BLOCK);
  Node guard=null;
  Node incr=null;
switch (n.getType()) {
case Token.FOR:
    guard=n.getFirstChild().getNext();
  incr=guard.getNext();
break;
case Token.WHILE:
guard=n.getFirstChild();
incr=IR.empty();
break;
case Token.DO:
guard=n.getLastChild();
if (!guard.isEmpty()) {
Node firstEntry=IR.name(GENERATOR_DO_WHILE_INITIAL);
enclosingBlock.addChildToFront(IR.var(firstEntry.cloneTree(),IR.trueNode()));
guard=IR.or(firstEntry,n.getLastChild().detachFromParent());
n.addChildToBack(guard);
}
incr=IR.empty();
break;
default :
break;
}
if (!controlCanExit(guard) && !controlCanExit(incr)) {
return;
}
Node guardName=IR.name(GENERATOR_LOOP_GUARD + generatorCounter.get());
if (!guard.isEmpty()) {
Node container=new Node(Token.BLOCK);
n.replaceChild(guard,container);
container.addChildToFront(IR.block(IR.exprResult(IR.assign(guardName.cloneTree(),guard.cloneTree()))));
container.addChildToBack(guardName.cloneTree());
}
if (!incr.isEmpty()) {
n.addChildBefore(IR.block(IR.exprResult(incr.detachFromParent())),n.getLastChild());
}
enclosingBlock.addChildToFront(IR.var(guardName));
compiler.reportCodeChange();
}
