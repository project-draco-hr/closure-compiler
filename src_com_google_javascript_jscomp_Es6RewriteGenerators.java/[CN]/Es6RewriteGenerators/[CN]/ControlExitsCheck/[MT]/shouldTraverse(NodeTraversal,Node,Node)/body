{
switch (n.getType()) {
case Token.FUNCTION:
    return false;
case Token.LABEL:
  labels.add(0,n.getFirstChild().getString());
break;
case Token.DO:
case Token.WHILE:
case Token.FOR:
continueCatchers++;
breakCatchers++;
break;
case Token.SWITCH:
breakCatchers++;
break;
case Token.BLOCK:
parent=n.getParent();
if (parent != null && parent.isTry() && parent.getFirstChild() == n && n.getNext().hasChildren()) {
throwCatchers++;
}
break;
case Token.BREAK:
if (!n.isGeneratorSafe() && ((breakCatchers == 0 && !n.hasChildren()) || (n.hasChildren() && !labels.contains(n.getFirstChild().getString())))) {
exited=true;
if (addJumps) {
parent.addChildBefore(createFinallyJumpBlock(finallyName,finallyStartState),n);
}
}
break;
case Token.CONTINUE:
if (continueCatchers == 0 || (n.hasChildren() && !labels.contains(n.getFirstChild().getString()))) {
exited=true;
if (addJumps) {
parent.addChildBefore(createFinallyJumpBlock(finallyName,finallyStartState),n);
}
}
break;
case Token.THROW:
if (throwCatchers == 0) {
exited=true;
if (addJumps && !n.isGeneratorSafe()) {
parent.addChildBefore(createFinallyJumpBlock(finallyName,finallyStartState),n);
}
}
break;
case Token.RETURN:
exited=true;
if (addJumps) {
parent.addChildBefore(createFinallyJumpBlock(finallyName,finallyStartState),n);
}
break;
case Token.YIELD:
exited=true;
break;
}
return true;
}
