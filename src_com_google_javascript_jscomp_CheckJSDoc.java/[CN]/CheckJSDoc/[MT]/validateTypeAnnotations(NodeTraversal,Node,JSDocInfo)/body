{
  if (info != null && info.hasType()) {
    boolean valid=false;
switch (n.getType()) {
case Token.CAST:
case Token.VAR:
case Token.LET:
case Token.CONST:
case Token.EXPORT:
      valid=true;
    break;
case Token.FUNCTION:
  valid=NodeUtil.isFunctionDeclaration(n);
break;
case Token.NAME:
case Token.DEFAULT_VALUE:
Node parent=n.getParent();
switch (parent.getType()) {
case Token.STRING_KEY:
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.CATCH:
case Token.FUNCTION:
case Token.VAR:
case Token.LET:
case Token.CONST:
case Token.PARAM_LIST:
valid=true;
break;
}
break;
case Token.STRING_KEY:
case Token.GETTER_DEF:
case Token.SETTER_DEF:
valid=true;
break;
case Token.ASSIGN:
valid=n.getParent().isExprResult() && (n.getFirstChild().isGetProp() || n.getFirstChild().isGetElem());
break;
case Token.GETPROP:
valid=n.getParent().isExprResult() && n.isQualifiedName();
break;
case Token.CALL:
valid=info.isDefine();
break;
default :
break;
}
if (!valid) {
t.getCompiler().report(t.makeError(n,MISPLACED_ANNOTATION,"type","Type annotations are not allowed here. " + "Are you missing parentheses?"));
}
}
}
