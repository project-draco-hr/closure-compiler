{
  Preconditions.checkArgument(inferred || type != null);
  boolean shouldDeclareOnGlobalThis=false;
  if (n.getType() == Token.NAME) {
    Preconditions.checkArgument(parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR || parent.getType() == Token.LP || parent.getType() == Token.CATCH);
    shouldDeclareOnGlobalThis=scope.isGlobal() && (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION);
  }
 else {
    Preconditions.checkArgument(n.getType() == Token.GETPROP && (parent.getType() == Token.ASSIGN || parent.getType() == Token.EXPR_RESULT));
  }
  String variableName=n.getQualifiedName();
  Preconditions.checkArgument(!variableName.isEmpty());
  if (scope.isDeclared(variableName,false)) {
    Var oldVar=scope.getVar(variableName);
    validator.expectUndeclaredVariable(sourceName,n,parent,oldVar,variableName,type);
  }
 else {
    if (!inferred) {
      setDeferredType(n,type);
    }
    CompilerInput input=compiler.getInput(sourceName);
    scope.declare(variableName,n,type,input,inferred);
    if (shouldDeclareOnGlobalThis) {
      ObjectType globalThis=typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);
      boolean isExtern=input.isExtern();
      if (inferred) {
        globalThis.defineInferredProperty(variableName,type == null ? typeRegistry.getNativeType(JSTypeNative.NO_TYPE) : type,isExtern);
      }
 else {
        globalThis.defineDeclaredProperty(variableName,type,isExtern);
      }
    }
    if (scope.isGlobal() && type instanceof FunctionType) {
      FunctionType fnType=(FunctionType)type;
      if (fnType.isConstructor() || fnType.isInterface()) {
        FunctionType superClassCtor=fnType.getSuperClassConstructor();
        scope.declare(variableName + ".prototype",n,fnType.getPrototype(),compiler.getInput(sourceName),superClassCtor == null || superClassCtor.getInstanceType().equals(typeRegistry.getNativeType(OBJECT_TYPE)));
      }
    }
  }
}
