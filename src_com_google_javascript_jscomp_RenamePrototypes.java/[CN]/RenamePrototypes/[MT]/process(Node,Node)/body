{
  Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());
  NodeTraversal.traverse(compiler,externs,new ProcessExternedProperties());
  NodeTraversal.traverse(compiler,root,new ProcessProperties());
  SortedSet<Property> propsByFrequency=new TreeSet<>(FREQUENCY_COMPARATOR);
  for (Iterator<Map.Entry<String,Property>> it=properties.entrySet().iterator(); it.hasNext(); ) {
    Property a=it.next().getValue();
    if (a.canRename() && !reservedNames.contains(a.oldName)) {
      propsByFrequency.add(a);
    }
 else {
      it.remove();
      reservedNames.add(a.oldName);
    }
  }
  if (prevUsedRenameMap != null) {
    reusePrototypeNames(propsByFrequency);
  }
  NameGenerator nameGen=new NameGenerator(reservedNames,"",reservedCharacters);
  StringBuilder debug=new StringBuilder();
  for (  Property a : propsByFrequency) {
    if (a.newName == null) {
      a.newName=nameGen.generateNextName();
      reservedNames.add(a.newName);
    }
    debug.append(a.oldName).append(" => ").append(a.newName).append('\n');
  }
  compiler.addToDebugLog("JS property assignments:\n" + debug);
  boolean changed=false;
  for (  Node n : stringNodes) {
    String oldName=n.getString();
    Property a=properties.get(oldName);
    if (a != null && a.newName != null) {
      n.setString(a.newName);
      changed=changed || !a.newName.equals(oldName);
    }
  }
  if (changed) {
    compiler.reportCodeChange();
  }
  compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED_OBFUSCATED);
}
