{
  boolean isExpressionClosure=false;
  if (!matchToken(Token.LC)) {
    if (compilerEnv.getLanguageVersion() < Context.VERSION_1_8) {
      reportError("msg.no.brace.body");
    }
 else {
      isExpressionClosure=true;
    }
  }
  ++nestingOfFunction;
  int pos=ts.tokenBeg;
  Block pn=new Block(pos);
  boolean inDirectivePrologue=true;
  boolean savedStrictMode=inUseStrictDirective;
  pn.setLineno(ts.lineno);
  try {
    if (isExpressionClosure) {
      ReturnStatement n=new ReturnStatement(ts.lineno);
      n.setReturnValue(assignExpr());
      n.putProp(Node.EXPRESSION_CLOSURE_PROP,Boolean.TRUE);
      pn.putProp(Node.EXPRESSION_CLOSURE_PROP,Boolean.TRUE);
      pn.addStatement(n);
    }
 else {
      bodyLoop:       for (; ; ) {
        AstNode n;
        int tt=peekToken();
switch (tt) {
case Token.ERROR:
case Token.EOF:
case Token.RC:
          break bodyLoop;
case Token.FUNCTION:
        consumeToken();
      n=function(FunctionNode.FUNCTION_STATEMENT);
    break;
default :
  n=statement();
if (inDirectivePrologue) {
  String directive=getDirective(n);
  if (directive == null) {
    inDirectivePrologue=false;
  }
 else   if (directive.equals("use strict")) {
    inUseStrictDirective=true;
  }
}
break;
}
pn.addStatement(n);
}
}
}
 catch (ParserException e) {
}
 finally {
--nestingOfFunction;
inUseStrictDirective=savedStrictMode;
}
int end=ts.tokenEnd;
getAndResetJsDoc();
if (!isExpressionClosure && mustMatchToken(Token.RC,"msg.no.brace.after.body")) end=ts.tokenEnd;
pn.setLength(end - pos);
return pn;
}
