{
  Preconditions.checkArgument(node.isCall() || node.isArrayLit() || node.isNew());
  List<Node> groups=new ArrayList<>();
  Node currGroup=null;
  Node callee=node.isArrayLit() ? null : node.removeFirstChild();
  Node currElement=node.removeFirstChild();
  while (currElement != null) {
    if (currElement.isSpread()) {
      if (currGroup != null) {
        groups.add(currGroup);
        currGroup=null;
      }
      groups.add(currElement.removeFirstChild());
    }
 else {
      if (currGroup == null) {
        currGroup=IR.arraylit();
      }
      currGroup.addChildToBack(currElement);
    }
    currElement=node.removeFirstChild();
  }
  if (currGroup != null) {
    groups.add(currGroup);
  }
  Node result=null;
  Node joinedGroups=IR.call(IR.getprop(IR.arraylit(),IR.string("concat")),groups.toArray(new Node[groups.size()]));
  if (node.isArrayLit()) {
    result=joinedGroups;
  }
 else   if (node.isCall()) {
    if (NodeUtil.mayHaveSideEffects(callee) && callee.isGetProp()) {
      Node statement=node;
      while (!NodeUtil.isStatement(statement)) {
        statement=statement.getParent();
      }
      Node freshVar=IR.name(FRESH_SPREAD_VAR + compiler.getUniqueNameIdSupplier().get());
      Node n=IR.var(freshVar.cloneTree());
      n.useSourceInfoIfMissingFromForTree(statement);
      statement.getParent().addChildBefore(n,statement);
      callee.addChildToFront(IR.assign(freshVar.cloneTree(),callee.removeFirstChild()));
      result=IR.call(IR.getprop(callee,IR.string("apply")),freshVar,joinedGroups);
    }
 else {
      Node context=callee.isGetProp() ? callee.getFirstChild().cloneTree() : IR.nullNode();
      result=IR.call(IR.getprop(callee,IR.string("apply")),context,joinedGroups);
    }
  }
 else {
    Node bindApply=NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),"Function.prototype.bind.apply");
    result=IR.newNode(bindApply,callee,joinedGroups);
  }
  result.useSourceInfoIfMissingFromForTree(node);
  parent.replaceChild(node,result);
  compiler.reportCodeChange();
}
