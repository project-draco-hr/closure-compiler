{
  Node rhs, nodeToDetach;
  if (NodeUtil.isNameDeclaration(parent)) {
    rhs=objectPattern.getLastChild();
    nodeToDetach=parent;
  }
 else   if (parent.isAssign() && parent.getParent().isExprResult()) {
    rhs=parent.getLastChild();
    nodeToDetach=parent.getParent();
  }
 else   if (parent.isStringKey() || parent.isArrayPattern() || parent.isDefaultValue()) {
    return;
  }
 else   if (parent.isParamList()) {
    return;
  }
 else {
    cannotConvertYet(objectPattern,"OBJECT_PATTERN that is a child of a " + Token.name(parent.getType()));
    return;
  }
  String tempVarName=DESTRUCTURING_TEMP_VAR + (destructuringVarCounter++);
  Node tempDecl=IR.var(IR.name(tempVarName),rhs.detachFromParent()).useSourceInfoIfMissingFromForTree(objectPattern);
  nodeToDetach.getParent().addChildBefore(tempDecl,nodeToDetach);
  for (Node child=objectPattern.getFirstChild(), next; child != null; child=next) {
    next=child.getNext();
    Node newLHS, newRHS;
    if (child.isStringKey()) {
      Node getprop=IR.getprop(IR.name(tempVarName),IR.string(child.getString()));
      if (!child.hasChildren()) {
        newLHS=child.detachFromParent();
        newRHS=getprop;
      }
 else {
        Node value=child.removeFirstChild();
        if (!value.isDefaultValue()) {
          newLHS=value;
          newRHS=getprop;
        }
 else {
          newLHS=value.removeFirstChild();
          Node defaultValue=value.removeFirstChild();
          newRHS=IR.hook(IR.sheq(getprop.cloneTree(),IR.name("undefined")),defaultValue,getprop);
        }
      }
    }
 else {
      Preconditions.checkState(child.isDefaultValue());
      newLHS=child.removeFirstChild();
      Node defaultValue=child.removeFirstChild();
      Node getprop=IR.getprop(IR.name(tempVarName),IR.string(newLHS.getString()));
      newRHS=IR.hook(IR.sheq(getprop.cloneTree(),IR.name("undefined")),defaultValue,getprop);
    }
    Node newNode;
    if (NodeUtil.isNameDeclaration(parent)) {
      newNode=IR.declaration(newLHS,newRHS,parent.getType());
    }
 else     if (parent.isAssign()) {
      newNode=IR.exprResult(IR.assign(newLHS,newRHS));
    }
 else {
      throw new IllegalStateException("not reached");
    }
    newNode.useSourceInfoIfMissingFromForTree(child);
    nodeToDetach.getParent().addChildBefore(newNode,nodeToDetach);
    visit(t,newLHS,newLHS.getParent());
  }
  nodeToDetach.detachFromParent();
  compiler.reportCodeChange();
}
