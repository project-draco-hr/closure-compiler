{
  checkClassReassignment(classNode);
  ClassDeclarationMetadata metadata=ClassDeclarationMetadata.create(classNode,parent);
  if (metadata == null || metadata.fullClassName == null) {
    cannotConvert(parent,"Can only convert classes that are declarations or the right hand" + " side of a simple assignment.");
    return;
  }
  if (metadata.hasSuperClass() && !metadata.superClassNameNode.isQualifiedName()) {
    compiler.report(JSError.make(metadata.superClassNameNode,DYNAMIC_EXTENDS_TYPE));
    return;
  }
  boolean useUnique=NodeUtil.isStatement(classNode) && !NodeUtil.isInFunction(classNode);
  String uniqueFullClassName=useUnique ? getUniqueClassName(metadata.fullClassName) : metadata.fullClassName;
  Node classNameAccess=NodeUtil.newQName(compiler,uniqueFullClassName);
  Node prototypeAccess=NodeUtil.newPropertyAccess(compiler,classNameAccess,"prototype");
  Preconditions.checkState(NodeUtil.isStatement(metadata.insertionPoint),"insertion point must be a statement: %s",metadata.insertionPoint);
  Node constructor=null;
  JSDocInfo ctorJSDocInfo=null;
  Node classMembers=classNode.getLastChild();
  Map<String,JSDocInfo> prototypeMembersToDeclare=new LinkedHashMap<>();
  Map<String,JSDocInfo> classMembersToDeclare=new LinkedHashMap<>();
  for (  Node member : classMembers.children()) {
    if (member.isEmpty()) {
      continue;
    }
    Preconditions.checkState(member.isMemberFunctionDef() || member.isGetterDef() || member.isSetterDef()|| (member.isComputedProp() && !member.getBooleanProp(Node.COMPUTED_PROP_VARIABLE)),"Member variables should have been transpiled earlier: ",member);
    if (member.isGetterDef() || member.isSetterDef()) {
      JSTypeExpression typeExpr=getTypeFromGetterOrSetter(member).clone();
      addToDefinePropertiesObject(metadata,member);
      Map<String,JSDocInfo> membersToDeclare=member.isStaticMember() ? classMembersToDeclare : prototypeMembersToDeclare;
      JSDocInfo existingJSDoc=membersToDeclare.get(member.getString());
      JSTypeExpression existingType=existingJSDoc == null ? null : existingJSDoc.getType();
      if (existingType != null && !existingType.equals(typeExpr)) {
        compiler.report(JSError.make(member,CONFLICTING_GETTER_SETTER_TYPE,member.getString()));
      }
 else {
        JSDocInfoBuilder jsDoc=new JSDocInfoBuilder(false);
        jsDoc.recordType(typeExpr);
        if (member.getJSDocInfo() != null && member.getJSDocInfo().isExport()) {
          jsDoc.recordExport();
        }
        membersToDeclare.put(member.getString(),jsDoc.build());
      }
    }
 else     if (member.isMemberFunctionDef() && member.getString().equals("constructor")) {
      ctorJSDocInfo=member.getJSDocInfo();
      constructor=member.getFirstChild().detachFromParent();
      if (!metadata.anonymous) {
        constructor.replaceChild(constructor.getFirstChild(),metadata.classNameNode.cloneNode());
      }
    }
 else {
      Node qualifiedMemberAccess=getQualifiedMemberAccess(compiler,member,classNameAccess,prototypeAccess);
      Node method=member.getLastChild().detachFromParent();
      Node assign=IR.assign(qualifiedMemberAccess,method);
      assign.useSourceInfoIfMissingFromForTree(member);
      JSDocInfo info=member.getJSDocInfo();
      if (member.isStaticMember() && NodeUtil.referencesThis(assign.getLastChild())) {
        JSDocInfoBuilder memberDoc=JSDocInfoBuilder.maybeCopyFrom(info);
        memberDoc.recordThisType(new JSTypeExpression(new Node(Token.BANG,new Node(Token.QMARK)),member.getSourceFileName()));
        info=memberDoc.build();
      }
      if (info != null) {
        assign.setJSDocInfo(info);
      }
      Node newNode=NodeUtil.newExpr(assign);
      metadata.insertNodeAndAdvance(newNode);
    }
  }
  for (  Map.Entry<String,JSDocInfo> entry : prototypeMembersToDeclare.entrySet()) {
    String declaredMember=entry.getKey();
    Node declaration=IR.getprop(prototypeAccess.cloneTree(),IR.string(declaredMember));
    declaration.setJSDocInfo(entry.getValue());
    metadata.insertNodeAndAdvance(IR.exprResult(declaration).useSourceInfoIfMissingFromForTree(classNode));
  }
  for (  Map.Entry<String,JSDocInfo> entry : classMembersToDeclare.entrySet()) {
    String declaredMember=entry.getKey();
    Node declaration=IR.getprop(classNameAccess.cloneTree(),IR.string(declaredMember));
    declaration.setJSDocInfo(entry.getValue());
    metadata.insertNodeAndAdvance(IR.exprResult(declaration).useSourceInfoIfMissingFromForTree(classNode));
  }
  if (metadata.definePropertiesObjForPrototype.hasChildren()) {
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,"Object.defineProperties"),prototypeAccess.cloneTree(),metadata.definePropertiesObjForPrototype));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertNodeAndAdvance(definePropsCall);
  }
  if (metadata.definePropertiesObjForClass.hasChildren()) {
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,"Object.defineProperties"),classNameAccess.cloneTree(),metadata.definePropertiesObjForClass));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertNodeAndAdvance(definePropsCall);
  }
  Preconditions.checkNotNull(constructor);
  JSDocInfo classJSDoc=NodeUtil.getBestJSDocInfo(classNode);
  JSDocInfoBuilder newInfo=JSDocInfoBuilder.maybeCopyFrom(classJSDoc);
  newInfo.recordConstructor();
  if (metadata.hasSuperClass()) {
    String superClassString=metadata.superClassNameNode.getQualifiedName();
    if (newInfo.isInterfaceRecorded()) {
      newInfo.recordExtendedInterface(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
 else {
      Node inherits=IR.call(NodeUtil.newQName(compiler,INHERITS),NodeUtil.newQName(compiler,metadata.fullClassName),NodeUtil.newQName(compiler,superClassString));
      Node inheritsCall=IR.exprResult(inherits);
      compiler.needsEs6Runtime=true;
      inheritsCall.useSourceInfoIfMissingFromForTree(classNode);
      Node enclosingStatement=NodeUtil.getEnclosingStatement(classNode);
      enclosingStatement.getParent().addChildAfter(inheritsCall,enclosingStatement);
      newInfo.recordBaseType(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
  }
  if (!newInfo.isUnrestrictedRecorded() && !newInfo.isDictRecorded() && !newInfo.isStructRecorded()) {
    newInfo.recordStruct();
  }
  if (ctorJSDocInfo != null) {
    newInfo.recordSuppressions(ctorJSDocInfo.getSuppressions());
    for (    String param : ctorJSDocInfo.getParameterNames()) {
      newInfo.recordParameter(param,ctorJSDocInfo.getParameterType(param));
    }
    newInfo.mergePropertyBitfieldFrom(ctorJSDocInfo);
  }
  if (NodeUtil.isStatement(classNode)) {
    constructor.getFirstChild().setString("");
    Node ctorVar=IR.let(metadata.classNameNode.cloneNode(),constructor);
    ctorVar.useSourceInfoIfMissingFromForTree(classNode);
    parent.replaceChild(classNode,ctorVar);
  }
 else {
    parent.replaceChild(classNode,constructor);
  }
  if (NodeUtil.isStatement(constructor)) {
    constructor.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isName()) {
    Node var=parent.getParent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (constructor.getParent().isName()) {
    Node var=constructor.getParent().getParent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isAssign()) {
    parent.setJSDocInfo(newInfo.build());
  }
 else {
    throw new IllegalStateException("Unexpected parent node " + parent);
  }
  compiler.reportCodeChange();
}
