{
  checkClassReassignment(classNode);
  Node className=classNode.getFirstChild();
  Node superClassName=className.getNext();
  Node classMembers=classNode.getLastChild();
  Node insertionPoint;
  if (!superClassName.isEmpty() && !superClassName.isQualifiedName()) {
    compiler.report(JSError.make(superClassName,DYNAMIC_EXTENDS_TYPE));
    return;
  }
  String fullClassName=null;
  boolean anonymous;
  if (NodeUtil.isStatement(classNode)) {
    fullClassName=className.getString();
    anonymous=false;
    insertionPoint=classNode;
  }
 else   if (parent.isAssign() && parent.getParent().isExprResult()) {
    fullClassName=parent.getFirstChild().getQualifiedName();
    if (fullClassName == null) {
      cannotConvert(parent,"Can only convert classes that are declarations or the right hand" + " side of a simple assignment.");
      return;
    }
    anonymous=true;
    insertionPoint=parent.getParent();
  }
 else   if (parent.isName()) {
    fullClassName=parent.getString();
    anonymous=true;
    insertionPoint=parent.getParent();
  }
 else {
    cannotConvert(parent,"Can only convert classes that are declarations or the right hand" + " side of a simple assignment.");
    return;
  }
  if (!className.isEmpty() && !className.getString().equals(fullClassName)) {
    cannotConvertYet(classNode,"named class in an assignment");
    return;
  }
  boolean useUnique=NodeUtil.isStatement(classNode) && !isInFunction(classNode);
  String uniqueFullClassName=useUnique ? getUniqueClassName(fullClassName) : fullClassName;
  String superClassString=superClassName.getQualifiedName();
  Verify.verify(NodeUtil.isStatement(insertionPoint));
  className.detachFromParent();
  Node constructor=null;
  JSDocInfo ctorJSDocInfo=null;
  for (  Node member : classMembers.children()) {
    if (member.getString().equals("constructor")) {
      ctorJSDocInfo=member.getJSDocInfo();
      constructor=member.getFirstChild().detachFromParent();
      if (!anonymous) {
        constructor.replaceChild(constructor.getFirstChild(),className);
      }
    }
 else {
      String qualifiedMemberName;
      if (member.isStaticMember()) {
        qualifiedMemberName=Joiner.on(".").join(uniqueFullClassName,member.getString());
      }
 else {
        qualifiedMemberName=Joiner.on(".").join(uniqueFullClassName,"prototype",member.getString());
      }
      Node assign=IR.assign(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),qualifiedMemberName,member,member.getString()),member.getFirstChild().detachFromParent());
      assign.srcref(member);
      JSDocInfo info=member.getJSDocInfo();
      if (info != null) {
        info.setAssociatedNode(assign);
        assign.setJSDocInfo(info);
      }
      Node newNode=NodeUtil.newExpr(assign);
      insertionPoint.getParent().addChildAfter(newNode,insertionPoint);
      insertionPoint=newNode;
    }
  }
  if (constructor == null) {
    Node name=anonymous ? IR.name("").srcref(className) : className;
    constructor=IR.function(name,IR.paramList().srcref(classNode),IR.block().srcref(classNode));
  }
  JSDocInfo classJSDoc=classNode.getJSDocInfo();
  JSDocInfoBuilder newInfo=(classJSDoc != null) ? JSDocInfoBuilder.copyFrom(classJSDoc) : new JSDocInfoBuilder(true);
  newInfo.recordConstructor();
  if (!superClassName.isEmpty()) {
    if (newInfo.isInterfaceRecorded()) {
      newInfo.recordExtendedInterface(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),superClassName.getSourceFileName()));
    }
 else {
      Node inherits=IR.call(IR.name(INHERITS),NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),fullClassName),NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),superClassString));
      inherits.putBooleanProp(Node.FREE_CALL,true);
      Node inheritsCall=IR.exprResult(inherits);
      inheritsCall.useSourceInfoIfMissingFromForTree(classNode);
      Node enclosingStatement=NodeUtil.getEnclosingStatement(classNode);
      enclosingStatement.getParent().addChildAfter(inheritsCall,enclosingStatement);
      newInfo.recordBaseType(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),superClassName.getSourceFileName()));
      Node copyProps=IR.call(IR.name(COPY_PROP).srcref(classNode),NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),fullClassName),NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),superClassString));
      copyProps.useSourceInfoIfMissingFromForTree(classNode);
      copyProps.putBooleanProp(Node.FREE_CALL,true);
      enclosingStatement.getParent().addChildAfter(IR.exprResult(copyProps).srcref(classNode),inheritsCall);
    }
  }
  if (!newInfo.isUnrestrictedRecorded() && !newInfo.isDictRecorded() && !newInfo.isStructRecorded()) {
    newInfo.recordStruct();
  }
  if (ctorJSDocInfo != null) {
    newInfo.recordSuppressions(ctorJSDocInfo.getSuppressions());
    for (    String param : ctorJSDocInfo.getParameterNames()) {
      newInfo.recordParameter(param,ctorJSDocInfo.getParameterType(param));
    }
  }
  insertionPoint=constructor;
  if (NodeUtil.isStatement(classNode)) {
    constructor.getFirstChild().setString("");
    Node ctorVar=IR.var(IR.name(fullClassName),constructor);
    ctorVar.useSourceInfoIfMissingFromForTree(classNode);
    parent.replaceChild(classNode,ctorVar);
  }
 else {
    parent.replaceChild(classNode,constructor);
  }
  if (NodeUtil.isStatement(constructor)) {
    insertionPoint.setJSDocInfo(newInfo.build(insertionPoint));
  }
 else   if (parent.isName()) {
    Node var=parent.getParent();
    var.setJSDocInfo(newInfo.build(var));
  }
 else   if (constructor.getParent().isName()) {
    Node var=constructor.getParent().getParent();
    var.setJSDocInfo(newInfo.build(var));
  }
 else   if (parent.isAssign()) {
    parent.setJSDocInfo(newInfo.build(parent));
  }
 else {
    throw new IllegalStateException("Unexpected parent node " + parent);
  }
  compiler.reportCodeChange();
}
