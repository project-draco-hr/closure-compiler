{
  Node enclosing=node.getParent();
  Node potentialCallee=node;
  if (!enclosing.isCall()) {
    enclosing=enclosing.getParent();
    potentialCallee=potentialCallee.getParent();
  }
  if (!(enclosing.isCall() && enclosing.getFirstChild() == potentialCallee)) {
    cannotConvertYet(node,"Only calls to super or to a method of super are supported.");
    return;
  }
  Node clazz=NodeUtil.getEnclosingClass(node);
  if (clazz == null) {
    compiler.report(JSError.make(node,NO_SUPERTYPE));
    return;
  }
  if (NodeUtil.getClassNameNode(clazz) == null) {
    return;
  }
  Node enclosingMemberDef=NodeUtil.getEnclosingClassMember(node);
  if (enclosingMemberDef.isStaticMember()) {
    node.getParent().replaceChild(node,clazz.getFirstChild().getNext().cloneTree());
    Node callTarget=IR.getprop(potentialCallee.detachFromParent(),IR.string("call"));
    callTarget.useSourceInfoIfMissingFromForTree(enclosing);
    enclosing.addChildToFront(callTarget);
    enclosing.addChildAfter(IR.thisNode(),callTarget);
    compiler.reportCodeChange();
    return;
  }
  Node methodName;
  Node callName=enclosing.removeFirstChild();
  if (callName.isSuper()) {
    methodName=IR.string(enclosingMemberDef.getString()).srcref(enclosing);
  }
 else {
    methodName=IR.string(callName.getLastChild().getString()).srcref(enclosing);
  }
  boolean useUnique=NodeUtil.isStatement(clazz) && !isInFunction(clazz);
  String uniqueClassString=useUnique ? getUniqueClassName(NodeUtil.getClassName(clazz)) : NodeUtil.getClassName(clazz);
  Node uniqueClassName=NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),uniqueClassString);
  uniqueClassName.useSourceInfoIfMissingFromForTree(enclosing);
  Node base=IR.getprop(uniqueClassName,IR.string("base").srcref(enclosing)).srcref(enclosing);
  enclosing.addChildToFront(methodName);
  enclosing.addChildToFront(IR.thisNode().srcref(enclosing));
  enclosing.addChildToFront(base);
  enclosing.putBooleanProp(Node.FREE_CALL,false);
  compiler.reportCodeChange();
}
