{
  Node rhs, nodeToDetach;
  if (NodeUtil.isNameDeclaration(parent)) {
    Preconditions.checkState(arrayPattern.getNext() == null);
    rhs=arrayPattern.getLastChild();
    nodeToDetach=parent;
  }
 else   if (parent.isAssign()) {
    rhs=arrayPattern.getNext();
    nodeToDetach=parent.getParent();
    Preconditions.checkState(nodeToDetach.isExprResult());
  }
 else   if (parent.isArrayPattern() || parent.isDefaultValue() || parent.isStringKey()) {
    return;
  }
 else {
    cannotConvertYet(arrayPattern,"ARRAY_PATTERN that is a child of a " + Token.name(parent.getType()));
    return;
  }
  String tempVarName=DESTRUCTURING_TEMP_VAR + (destructuringVarCounter++);
  Node tempDecl=IR.var(IR.name(tempVarName),rhs.detachFromParent()).useSourceInfoFromForTree(arrayPattern);
  nodeToDetach.getParent().addChildBefore(tempDecl,nodeToDetach);
  int i=0;
  for (Node child=arrayPattern.getFirstChild(), next; child != null; child=next, i++) {
    next=child.getNext();
    if (child.isEmpty()) {
      continue;
    }
    Node newLHS, newRHS;
    if (child.isDefaultValue()) {
      Node getElem=IR.getelem(IR.name(tempVarName),IR.number(i));
      newLHS=child.getFirstChild().detachFromParent();
      newRHS=IR.hook(IR.sheq(getElem.cloneTree(),IR.name("undefined")),child.getLastChild().detachFromParent(),getElem);
    }
 else {
      newLHS=child.detachFromParent();
      newRHS=IR.getelem(IR.name(tempVarName),IR.number(i));
    }
    Node newNode;
    if (parent.isAssign()) {
      Node assignment=IR.assign(newLHS,newRHS);
      newNode=IR.exprResult(assignment);
    }
 else {
      newNode=IR.declaration(newLHS,newRHS,parent.getType());
    }
    newNode.useSourceInfoFromForTree(arrayPattern);
    nodeToDetach.getParent().addChildBefore(newNode,nodeToDetach);
    visit(t,newLHS,newLHS.getParent());
  }
  nodeToDetach.detachFromParent();
  compiler.reportCodeChange();
}
