{
  Node insertSpot=null;
  Node block=function.getLastChild();
  for (int i=0; i < paramList.getChildCount(); i++) {
    Node param=paramList.getChildAtIndex(i);
    if (param.isDefaultValue()) {
      Node name=param.removeFirstChild();
      Node defaultValue=param.removeFirstChild();
      paramList.replaceChild(param,name);
      name.setOptionalArg(true);
      Node stm=IR.exprResult(IR.and(IR.sheq(name.cloneNode(),IR.name("undefined")),IR.assign(name.cloneNode(),defaultValue)));
      block.addChildAfter(stm.useSourceInfoIfMissingFromForTree(param),insertSpot);
      insertSpot=stm;
      compiler.reportCodeChange();
    }
 else     if (param.isRest()) {
      param.setType(Token.NAME);
      param.setVarArgs(true);
      Node newArr=IR.exprResult(IR.assign(IR.name(param.getString()),IR.call(IR.getprop(IR.getprop(IR.arraylit(),IR.string("slice")),IR.string("call")),IR.name("arguments"),IR.number(i))));
      block.addChildAfter(newArr.useSourceInfoIfMissingFromForTree(param),insertSpot);
      compiler.reportCodeChange();
    }
 else     if (param.isObjectPattern()) {
      Node pattern=param;
      String tempVarName=DESTRUCTURING_TEMP_VAR + (destructuringVarCounter++);
      paramList.replaceChild(param,IR.name(tempVarName));
      for (Node child=pattern.getFirstChild(); child != null; child=child.getNext()) {
        if (child.isComputedProp()) {
          cannotConvertYet(child,"computed property in an object pattern");
          return;
        }
        Node newName;
        if (child.hasChildren()) {
          if (child.getFirstChild().isDefaultValue()) {
            cannotConvertYet(child.getFirstChild(),"default value in an object pattern in a param list");
            return;
          }
          newName=child.removeFirstChild();
        }
 else {
          newName=IR.name(child.getString());
        }
        Node newDecl=IR.var(newName,IR.getprop(IR.name(tempVarName),IR.string(child.getString())));
        newDecl.useSourceInfoIfMissingFromForTree(child);
        block.addChildAfter(newDecl,insertSpot);
      }
      compiler.reportCodeChange();
    }
  }
}
