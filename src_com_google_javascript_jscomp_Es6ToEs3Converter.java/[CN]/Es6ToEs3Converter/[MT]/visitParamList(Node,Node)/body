{
  Node insertSpot=null;
  Node block=function.getLastChild();
  for (int i=0; i < paramList.getChildCount(); i++) {
    Node param=paramList.getChildAtIndex(i);
    if (param.isDefaultValue()) {
      Node name=param.removeFirstChild();
      Node defaultValue=param.removeFirstChild();
      paramList.replaceChild(param,name);
      name.setOptionalArg(true);
      Node stm=IR.exprResult(IR.and(IR.sheq(name.cloneNode(),IR.name("undefined")),IR.assign(name.cloneNode(),defaultValue)));
      block.addChildAfter(stm.useSourceInfoIfMissingFromForTree(param),insertSpot);
      insertSpot=stm;
      compiler.reportCodeChange();
    }
 else     if (param.isRest()) {
      param.setType(Token.NAME);
      param.setVarArgs(true);
      Node newArr=IR.exprResult(IR.assign(IR.name(param.getString()),IR.call(IR.getprop(IR.getprop(IR.arraylit(),IR.string("slice")),IR.string("call")),IR.name("arguments"),IR.number(i))));
      block.addChildAfter(newArr.useSourceInfoIfMissingFromForTree(param),insertSpot);
      compiler.reportCodeChange();
    }
 else     if (param.isObjectPattern()) {
      String tempVarName=DESTRUCTURING_TEMP_VAR + (destructuringVarCounter++);
      paramList.replaceChild(param,IR.name(tempVarName));
      for (Node child=param.getFirstChild(); child != null; child=child.getNext()) {
        Node newLHS, newRHS;
        if (child.isComputedProp()) {
          Node getelem=IR.getelem(IR.name(tempVarName),child.removeFirstChild());
          if (child.getLastChild().isDefaultValue()) {
            newLHS=child.getFirstChild().removeFirstChild();
            newRHS=defaultValueHook(getelem,child.getFirstChild().getLastChild().detachFromParent());
          }
 else {
            newLHS=child.removeFirstChild();
            newRHS=getelem;
          }
        }
 else         if (child.isStringKey()) {
          if (child.hasChildren()) {
            Node getprop=new Node(child.isQuotedString() ? Token.GETELEM : Token.GETPROP,IR.name(tempVarName),IR.string(child.getString()));
            if (child.getFirstChild().isDefaultValue()) {
              newLHS=child.getFirstChild().removeFirstChild();
              newRHS=defaultValueHook(getprop,child.getFirstChild().getLastChild().detachFromParent());
            }
 else {
              newLHS=child.removeFirstChild();
              newRHS=getprop;
            }
          }
 else {
            newLHS=IR.name(child.getString());
            newRHS=IR.getprop(IR.name(tempVarName),IR.string(child.getString()));
          }
        }
 else         if (child.isDefaultValue()) {
          newLHS=child.removeFirstChild();
          Node getprop=IR.getprop(IR.name(tempVarName),IR.string(newLHS.getString()));
          newRHS=defaultValueHook(getprop,child.removeFirstChild());
        }
 else {
          Preconditions.checkState(false,"Unexpected object pattern child: %s",child);
          return;
        }
        Node newDecl=IR.var(newLHS,newRHS);
        newDecl.useSourceInfoIfMissingFromForTree(child);
        block.addChildAfter(newDecl,insertSpot);
      }
      compiler.reportCodeChange();
    }
  }
}
