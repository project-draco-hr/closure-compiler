{
  Preconditions.checkState(!inLoop,"Nested loops are forbidden");
  inLoop=true;
  if (randomizeLoops) {
    randomizePasses();
  }
 else {
    optimizePasses();
  }
  scopeHandler=new ScopedChangeHandler();
  compiler.addChangeHandler(scopeHandler);
  setScope(root);
  lastRuns=new HashMap<NamedPass,Integer>();
  for (  NamedPass pass : myPasses) {
    lastRuns.put(pass,START_TIME);
  }
  Set<NamedPass> madeChanges=new HashSet<NamedPass>();
  Set<NamedPass> runInPrevIter=new HashSet<NamedPass>();
  State s=State.RUN_PASSES_NOT_RUN_IN_PREV_ITER;
  boolean lastIterMadeChanges;
  int count=0;
  try {
    while (true) {
      if (count++ > MAX_LOOPS) {
        compiler.throwInternalError(OPTIMIZE_LOOP_ERROR,null);
      }
      lastIterMadeChanges=false;
      for (      NamedPass pass : myPasses) {
        if ((s == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER && !runInPrevIter.contains(pass)) || (s == State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER && madeChanges.contains(pass))) {
          timestamp++;
          currentPass=pass;
          pass.process(externs,root);
          runInPrevIter.add(pass);
          lastRuns.put(pass,timestamp);
          if (hasHaltingErrors()) {
            return;
          }
 else           if (scopeHandler.hasCodeChangedSinceLastCall()) {
            madeChanges.add(pass);
            lastIterMadeChanges=true;
          }
 else {
            madeChanges.remove(pass);
          }
        }
 else {
          runInPrevIter.remove(pass);
        }
      }
      if (s == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER) {
        if (lastIterMadeChanges) {
          s=State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER;
        }
 else {
          return;
        }
      }
 else       if (!lastIterMadeChanges) {
        s=State.RUN_PASSES_NOT_RUN_IN_PREV_ITER;
      }
    }
  }
  finally {
    inLoop=false;
    compiler.removeChangeHandler(scopeHandler);
  }
}
