{
  if (export.getBooleanProp(Node.EXPORT_DEFAULT)) {
    Node child=export.getFirstChild();
    String name=null;
    if (child.isFunction()) {
      name=NodeUtil.getFunctionName(child);
    }
 else     if (child.isClass()) {
      name=NodeUtil.getClassName(child);
    }
    if (name != null) {
      Node decl=child.cloneTree();
      decl.setJSDocInfo(export.getJSDocInfo());
      parent.replaceChild(export,decl);
      exportMap.put("default",new NameNodePair(name,child));
    }
 else {
      Node var=IR.var(IR.name(DEFAULT_EXPORT_NAME),export.removeFirstChild());
      var.useSourceInfoIfMissingFromForTree(export);
      parent.replaceChild(export,var);
      exportMap.put("default",new NameNodePair(DEFAULT_EXPORT_NAME,child));
    }
  }
 else   if (export.getBooleanProp(Node.EXPORT_ALL_FROM)) {
    compiler.report(JSError.make(export,Es6ToEs3Converter.CANNOT_CONVERT_YET,"Wildcard export"));
  }
 else   if (export.getChildCount() == 2) {
    Node moduleIdentifier=export.getLastChild();
    Node importNode=new Node(Token.IMPORT,moduleIdentifier.cloneNode());
    importNode.copyInformationFrom(export);
    parent.addChildBefore(importNode,export);
    visit(t,importNode,parent);
    String loadAddress=loader.locate(moduleIdentifier.getString(),t.getInput());
    String moduleName=toModuleName(loadAddress);
    for (    Node exportSpec : export.getFirstChild().children()) {
      String nameFromOtherModule=exportSpec.getFirstChild().getString();
      String exportedName=exportSpec.getLastChild().getString();
      exportMap.put(exportedName,new NameNodePair(moduleName + "." + nameFromOtherModule,exportSpec));
    }
    parent.removeChild(export);
  }
 else {
    if (export.getFirstChild().getType() == Token.EXPORT_SPECS) {
      for (      Node exportSpec : export.getFirstChild().children()) {
        Node origName=exportSpec.getFirstChild();
        exportMap.put(exportSpec.getChildCount() == 2 ? exportSpec.getLastChild().getString() : origName.getString(),new NameNodePair(origName.getString(),exportSpec));
      }
      parent.removeChild(export);
    }
 else {
      Node declaration=export.getFirstChild();
      for (int i=0; i < declaration.getChildCount(); i++) {
        Node maybeName=declaration.getChildAtIndex(i);
        if (!maybeName.isName()) {
          break;
        }
        if (declaration.isClass() && i > 0) {
          break;
        }
        String name=maybeName.getString();
        Var v=t.getScope().getVar(name);
        if (v == null || v.isGlobal()) {
          exportMap.put(name,new NameNodePair(name,maybeName));
        }
        if (declaration.isClass()) {
          classes.add(name);
        }
        if (export.getJSDocInfo() != null && export.getJSDocInfo().hasTypedefType()) {
          typedefs.add(name);
        }
      }
      declaration.setJSDocInfo(export.getJSDocInfo());
      export.setJSDocInfo(null);
      parent.replaceChild(export,declaration.detachFromParent());
    }
    compiler.reportCodeChange();
  }
}
