{
  String importName=importDecl.getLastChild().getString();
  String loadAddress=loader.locate(importName,t.getInput());
  try {
    loader.load(loadAddress);
  }
 catch (  ES6ModuleLoader.LoadFailedException e) {
    compiler.report(t.makeError(importDecl,ES6ModuleLoader.LOAD_ERROR,importName));
  }
  String moduleName=toModuleName(loadAddress);
  Set<String> namesToRequire=new LinkedHashSet<>();
  for (  Node child : importDecl.children()) {
    if (child.isEmpty() || child.isString()) {
      continue;
    }
 else     if (child.isName()) {
      importMap.put(child.getString(),new ModuleOriginalNamePair(moduleName,child.getString()));
      namesToRequire.add(child.getString());
    }
 else {
      for (      Node grandChild : child.children()) {
        String origName=grandChild.getFirstChild().getString();
        namesToRequire.add(origName);
        if (grandChild.getChildCount() == 2) {
          importMap.put(grandChild.getLastChild().getString(),new ModuleOriginalNamePair(moduleName,origName));
        }
 else {
          importMap.put(origName,new ModuleOriginalNamePair(moduleName,origName));
        }
      }
    }
  }
  Node script=NodeUtil.getEnclosingType(parent,Token.SCRIPT);
  if (!alreadyRequired.contains(moduleName)) {
    alreadyRequired.add(moduleName);
    Node require=IR.exprResult(IR.call(compiler.newQualifiedNameNode("goog.require"),IR.string(moduleName)));
    require.copyInformationFromForTree(importDecl);
    script.addChildToFront(require);
    if (reportDependencies) {
      t.getInput().addRequire(moduleName);
    }
  }
  for (  String name : namesToRequire) {
    Node require=IR.exprResult(IR.call(compiler.newQualifiedNameNode("goog.require"),IR.string(moduleName + "." + name)));
    require.copyInformationFromForTree(importDecl);
    script.addChildToFront(require);
    if (reportDependencies) {
      t.getInput().addRequire(moduleName + "." + name);
    }
  }
  parent.removeChild(importDecl);
  compiler.reportCodeChange();
}
