{
  String importName=n.getLastChild().getString();
  String loadAddress=loader.locate(importName,t.getInput());
  try {
    loader.load(loadAddress);
  }
 catch (  ES6ModuleLoader.LoadFailedException e) {
    t.makeError(n,ES6ModuleLoader.LOAD_ERROR,importName);
  }
  String moduleName=toModuleName(loadAddress);
  Set<String> namesToRequire=new LinkedHashSet<>();
  for (  Node child : n.children()) {
    if (child.isEmpty() || child.isString()) {
      continue;
    }
 else     if (child.isName()) {
      importMap.put(child.getString(),new ModuleOriginalNamePair(moduleName,child.getString()));
      namesToRequire.add(child.getString());
    }
 else {
      for (      Node grandChild : child.children()) {
        String origName=grandChild.getFirstChild().getString();
        namesToRequire.add(origName);
        if (grandChild.getChildCount() == 2) {
          importMap.put(grandChild.getLastChild().getString(),new ModuleOriginalNamePair(moduleName,origName));
        }
 else {
          importMap.put(origName,new ModuleOriginalNamePair(moduleName,origName));
        }
      }
    }
  }
  Node script=NodeUtil.getEnclosingType(parent,Token.SCRIPT);
  if (!alreadyRequired.contains(moduleName)) {
    alreadyRequired.add(moduleName);
    script.addChildToFront(IR.exprResult(IR.call(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),"goog.require"),IR.string(moduleName))).copyInformationFromForTree(n));
    if (reportDependencies) {
      t.getInput().addRequire(moduleName);
    }
  }
  for (  String name : namesToRequire) {
    script.addChildToFront(IR.exprResult(IR.call(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(),"goog.require"),IR.string(moduleName + "." + name))).copyInformationFromForTree(n));
    if (reportDependencies) {
      t.getInput().addRequire(moduleName + "." + name);
    }
  }
  parent.removeChild(n);
  compiler.reportCodeChange();
}
