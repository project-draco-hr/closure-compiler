{
  JSTypeExpression type;
  int lineno=stream.getLineno();
  int charno=stream.getCharno();
  String annotationName=stream.getString();
  Annotation annotation=annotationNames.get(annotationName);
  if (annotation == null) {
    parser.addParserWarning("msg.bad.jsdoc.tag",annotationName,stream.getLineno(),stream.getCharno());
  }
 else {
    jsdocBuilder.markAnnotation(annotationName,lineno,charno);
switch (annotation) {
case NG_INJECT:
      if (jsdocBuilder.isNgInjectRecorded()) {
        parser.addParserWarning("msg.jsdoc.nginject.extra",stream.getLineno(),stream.getCharno());
      }
 else {
        jsdocBuilder.recordNgInject(true);
      }
    return eatUntilEOLIfNotAnnotation();
case JAGGER_INJECT:
  if (jsdocBuilder.isJaggerInjectRecorded()) {
    parser.addParserWarning("msg.jsdoc.jaggerInject.extra",stream.getLineno(),stream.getCharno());
  }
 else {
    jsdocBuilder.recordJaggerInject(true);
  }
return eatUntilEOLIfNotAnnotation();
case JAGGER_MODULE:
if (jsdocBuilder.isJaggerModuleRecorded()) {
parser.addParserWarning("msg.jsdoc.jaggerModule.extra",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.recordJaggerModule(true);
}
return eatUntilEOLIfNotAnnotation();
case JAGGER_PROVIDE:
if (jsdocBuilder.isJaggerProvideRecorded()) {
parser.addParserWarning("msg.jsdoc.jaggerProvide.extra",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.recordJaggerProvide(true);
}
return eatUntilEOLIfNotAnnotation();
case JAGGER_PROVIDE_PROMISE:
if (jsdocBuilder.isJaggerProvidePromiseRecorded()) {
parser.addParserWarning("msg.jsdoc.jaggerProvidePromise.extra",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.recordJaggerProvidePromise(true);
}
return eatUntilEOLIfNotAnnotation();
case AUTHOR:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo authorInfo=extractSingleLineBlock();
String author=authorInfo.string;
if (author.isEmpty()) {
parser.addParserWarning("msg.jsdoc.authormissing",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.addAuthor(author);
}
token=authorInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case CONSISTENTIDGENERATOR:
if (!jsdocBuilder.recordConsistentIdGenerator()) {
parser.addParserWarning("msg.jsdoc.consistidgen",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case UNRESTRICTED:
if (!jsdocBuilder.recordUnrestricted()) {
parser.addTypeWarning("msg.jsdoc.incompat.type",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case STRUCT:
if (!jsdocBuilder.recordStruct()) {
parser.addTypeWarning("msg.jsdoc.incompat.type",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case DICT:
if (!jsdocBuilder.recordDict()) {
parser.addTypeWarning("msg.jsdoc.incompat.type",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case CONSTRUCTOR:
if (!jsdocBuilder.recordConstructor()) {
if (jsdocBuilder.isInterfaceRecorded()) {
parser.addTypeWarning("msg.jsdoc.interface.constructor",stream.getLineno(),stream.getCharno());
}
 else {
parser.addTypeWarning("msg.jsdoc.incompat.type",stream.getLineno(),stream.getCharno());
}
}
return eatUntilEOLIfNotAnnotation();
case DEPRECATED:
if (!jsdocBuilder.recordDeprecated()) {
parser.addParserWarning("msg.jsdoc.deprecated",stream.getLineno(),stream.getCharno());
}
ExtractionInfo reasonInfo=extractMultilineTextualBlock(token);
String reason=reasonInfo.string;
if (reason.length() > 0) {
jsdocBuilder.recordDeprecationReason(reason);
}
token=reasonInfo.token;
return token;
case INTERFACE:
if (!jsdocBuilder.recordInterface()) {
if (jsdocBuilder.isConstructorRecorded()) {
parser.addTypeWarning("msg.jsdoc.interface.constructor",stream.getLineno(),stream.getCharno());
}
 else {
parser.addTypeWarning("msg.jsdoc.incompat.type",stream.getLineno(),stream.getCharno());
}
}
return eatUntilEOLIfNotAnnotation();
case DESC:
if (jsdocBuilder.isDescriptionRecorded()) {
parser.addParserWarning("msg.jsdoc.desc.extra",stream.getLineno(),stream.getCharno());
return eatUntilEOLIfNotAnnotation();
}
 else {
ExtractionInfo descriptionInfo=extractMultilineTextualBlock(token);
String description=descriptionInfo.string;
jsdocBuilder.recordDescription(description);
token=descriptionInfo.token;
return token;
}
case FILE_OVERVIEW:
String fileOverview="";
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo fileOverviewInfo=extractMultilineTextualBlock(token,WhitespaceOption.TRIM);
fileOverview=fileOverviewInfo.string;
token=fileOverviewInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
if (!jsdocBuilder.recordFileOverview(fileOverview)) {
parser.addParserWarning("msg.jsdoc.fileoverview.extra",stream.getLineno(),stream.getCharno());
}
return token;
case LICENSE:
case PRESERVE:
ExtractionInfo preserveInfo=extractMultilineTextualBlock(token,WhitespaceOption.PRESERVE);
String preserve=preserveInfo.string;
if (preserve.length() > 0) {
if (fileLevelJsDocBuilder != null) {
fileLevelJsDocBuilder.append(preserve);
}
}
token=preserveInfo.token;
return token;
case ENUM:
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
type=createJSTypeExpression(parseAndRecordTypeNode(token));
}
if (type == null) {
type=createJSTypeExpression(newStringNode("number"));
}
if (!jsdocBuilder.recordEnumParameterType(type)) {
parser.addTypeWarning("msg.jsdoc.incompat.type",lineno,charno);
}
token=eatUntilEOLIfNotAnnotation(token);
return token;
case EXPORT:
if (!jsdocBuilder.recordExport()) {
parser.addParserWarning("msg.jsdoc.export",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case EXPOSE:
if (!jsdocBuilder.recordExpose()) {
parser.addParserWarning("msg.jsdoc.expose",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case EXTERNS:
if (!jsdocBuilder.recordExterns()) {
parser.addParserWarning("msg.jsdoc.externs",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case JAVA_DISPATCH:
if (!jsdocBuilder.recordJavaDispatch()) {
parser.addParserWarning("msg.jsdoc.javadispatch",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case EXTENDS:
case IMPLEMENTS:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
boolean matchingRc=false;
if (token == JsDocToken.LC) {
token=next();
matchingRc=true;
}
if (token == JsDocToken.STRING) {
Node typeNode=parseAndRecordTypeNameNode(token,lineno,charno,matchingRc);
lineno=stream.getLineno();
charno=stream.getCharno();
typeNode=wrapNode(Token.BANG,typeNode);
type=createJSTypeExpression(typeNode);
if (annotation == Annotation.EXTENDS) {
extendedTypes.add(new ExtendedTypeInfo(type,stream.getLineno(),stream.getCharno()));
}
 else {
Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
if (!jsdocBuilder.recordImplementedInterface(type)) {
parser.addTypeWarning("msg.jsdoc.implements.duplicate",lineno,charno);
}
}
token=next();
if (matchingRc) {
if (token != JsDocToken.RC) {
parser.addTypeWarning("msg.jsdoc.missing.rc",stream.getLineno(),stream.getCharno());
}
 else {
token=next();
}
}
 else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
parser.addTypeWarning("msg.end.annotation.expected",stream.getLineno(),stream.getCharno());
}
}
 else {
parser.addTypeWarning("msg.no.type.name",lineno,charno);
}
token=eatUntilEOLIfNotAnnotation(token);
return token;
case HIDDEN:
if (!jsdocBuilder.recordHiddenness()) {
parser.addParserWarning("msg.jsdoc.hidden",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case LENDS:
skipEOLs();
matchingRc=false;
if (match(JsDocToken.LC)) {
token=next();
matchingRc=true;
}
if (match(JsDocToken.STRING)) {
token=next();
if (!jsdocBuilder.recordLends(stream.getString())) {
parser.addTypeWarning("msg.jsdoc.lends.incompatible",stream.getLineno(),stream.getCharno());
}
}
 else {
parser.addTypeWarning("msg.jsdoc.lends.missing",stream.getLineno(),stream.getCharno());
}
if (matchingRc && !match(JsDocToken.RC)) {
parser.addTypeWarning("msg.jsdoc.missing.rc",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case MEANING:
ExtractionInfo meaningInfo=extractMultilineTextualBlock(token);
String meaning=meaningInfo.string;
token=meaningInfo.token;
if (!jsdocBuilder.recordMeaning(meaning)) {
parser.addParserWarning("msg.jsdoc.meaning.extra",stream.getLineno(),stream.getCharno());
}
return token;
case NO_ALIAS:
if (!jsdocBuilder.recordNoAlias()) {
parser.addParserWarning("msg.jsdoc.noalias",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_COMPILE:
if (!jsdocBuilder.recordNoCompile()) {
parser.addParserWarning("msg.jsdoc.nocompile",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_TYPE_CHECK:
if (!jsdocBuilder.recordNoTypeCheck()) {
parser.addParserWarning("msg.jsdoc.nocheck",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NOT_IMPLEMENTED:
return eatUntilEOLIfNotAnnotation();
case INHERIT_DOC:
case OVERRIDE:
if (!jsdocBuilder.recordOverride()) {
parser.addTypeWarning("msg.jsdoc.override",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case THROWS:
{
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token == JsDocToken.LC) {
type=createJSTypeExpression(parseAndRecordTypeNode(token));
if (type == null) {
return eatUntilEOLIfNotAnnotation();
}
}
token=current();
jsdocBuilder.recordThrowType(type);
boolean isAnnotationNext=lookAheadForAnnotation();
if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) {
ExtractionInfo descriptionInfo=extractMultilineTextualBlock(token);
String description=descriptionInfo.string;
if (description.length() > 0) {
jsdocBuilder.recordThrowDescription(type,description);
}
token=descriptionInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
}
case PARAM:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token == JsDocToken.LC) {
type=createJSTypeExpression(parseAndRecordParamTypeNode(token));
if (type == null) {
return eatUntilEOLIfNotAnnotation();
}
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
}
String name=null;
boolean isBracketedParam=JsDocToken.LB == token;
if (isBracketedParam) {
token=next();
}
if (JsDocToken.STRING != token) {
parser.addTypeWarning("msg.missing.variable.name",lineno,charno);
}
 else {
name=stream.getString();
if (isBracketedParam) {
token=next();
if (JsDocToken.EQUALS == token) {
token=next();
if (JsDocToken.STRING == token) {
token=next();
}
}
if (JsDocToken.RB != token) {
reportTypeSyntaxWarning("msg.jsdoc.missing.rb");
}
 else if (type != null) {
type=JSTypeExpression.makeOptionalArg(type);
}
}
if (name.indexOf('.') > -1) {
parser.addParserWarning("msg.invalid.variable.name",name,lineno,charno);
name=null;
}
 else if (!jsdocBuilder.recordParameter(name,type)) {
if (jsdocBuilder.hasParameter(name)) {
parser.addTypeWarning("msg.dup.variable.name",name,lineno,charno);
}
 else {
parser.addTypeWarning("msg.jsdoc.incompat.type",name,lineno,charno);
}
}
}
if (name == null) {
token=eatUntilEOLIfNotAnnotation(token);
return token;
}
jsdocBuilder.markName(name,sourceFile,lineno,charno);
if (jsdocBuilder.shouldParseDocumentation() && token != JsDocToken.ANNOTATION) {
ExtractionInfo paramDescriptionInfo=extractMultilineTextualBlock(token);
String paramDescription=paramDescriptionInfo.string;
if (paramDescription.length() > 0) {
jsdocBuilder.recordParameterDescription(name,paramDescription);
}
token=paramDescriptionInfo.token;
}
 else if (token != JsDocToken.EOC && token != JsDocToken.EOF) {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case PRESERVE_TRY:
if (!jsdocBuilder.recordPreserveTry()) {
parser.addParserWarning("msg.jsdoc.preservertry",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_SHADOW:
if (!jsdocBuilder.recordNoShadow()) {
parser.addParserWarning("msg.jsdoc.noshadow",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case NO_SIDE_EFFECTS:
if (!jsdocBuilder.recordNoSideEffects()) {
parser.addParserWarning("msg.jsdoc.nosideeffects",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case MODIFIES:
token=parseModifiesTag(next());
return token;
case IMPLICIT_CAST:
if (!jsdocBuilder.recordImplicitCast()) {
parser.addTypeWarning("msg.jsdoc.implicitcast",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case SEE:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo referenceInfo=extractSingleLineBlock();
String reference=referenceInfo.string;
if (reference.isEmpty()) {
parser.addParserWarning("msg.jsdoc.seemissing",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.addReference(reference);
}
token=referenceInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case STABLEIDGENERATOR:
if (!jsdocBuilder.recordStableIdGenerator()) {
parser.addParserWarning("msg.jsdoc.stableidgen",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case SUPPRESS:
token=parseSuppressTag(next());
return token;
case TEMPLATE:
{
int templateLineno=stream.getLineno();
int templateCharno=stream.getCharno();
ExtractionInfo templateInfo=extractMultilineTextualBlock(token,WhitespaceOption.TRIM);
String templateString=templateInfo.string;
String ttlStartDelimiter=":=";
String ttlEndDelimiter="=:";
String templateNames;
String typeTransformationExpr="";
boolean isTypeTransformation=false;
boolean validTypeTransformation=true;
if (!templateString.contains(ttlStartDelimiter)) {
if (templateString.contains("\n")) {
templateNames=templateString.substring(0,templateString.indexOf('\n'));
}
 else {
templateNames=templateString;
}
}
 else {
int ttlStartIndex=templateString.indexOf(ttlStartDelimiter);
templateNames=templateString.substring(0,ttlStartIndex);
if (!templateString.contains(ttlEndDelimiter)) {
validTypeTransformation=false;
parser.addTypeWarning("msg.jsdoc.typetransformation.missing.delimiter",templateLineno,templateCharno);
}
 else {
isTypeTransformation=true;
int ttlEndIndex=templateString.indexOf(ttlEndDelimiter);
typeTransformationExpr=templateString.substring(ttlStartIndex + ttlStartDelimiter.length(),ttlEndIndex).trim();
}
}
List<String> names=Lists.newArrayList(Splitter.on(',').trimResults().split(templateNames));
if (names.size() == 1 && names.get(0).isEmpty()) {
parser.addTypeWarning("msg.jsdoc.templatemissing",templateLineno,templateCharno);
}
 else {
for (String typeName : names) {
if (!validTemplateTypeName(typeName)) {
parser.addTypeWarning("msg.jsdoc.template.invalid.type.name",templateLineno,templateCharno);
}
 else if (!jsdocBuilder.recordTemplateTypeName(typeName)) {
parser.addTypeWarning("msg.jsdoc.template.name.declared.twice",templateLineno,templateCharno);
}
}
}
if (isTypeTransformation) {
if (names.size() > 1) {
parser.addTypeWarning("msg.jsdoc.typetransformation.with.multiple.names",templateLineno,templateCharno);
}
if (typeTransformationExpr.isEmpty()) {
validTypeTransformation=false;
parser.addTypeWarning("msg.jsdoc.typetransformation.expression.missing",templateLineno,templateCharno);
}
if (validTypeTransformation) {
TypeTransformationParser ttlParser=new TypeTransformationParser(typeTransformationExpr,sourceFile,errorReporter,templateLineno,templateCharno);
if (ttlParser.parseTypeTransformation()) {
Node ttlAst=ttlParser.getTypeTransformationAst();
}
}
}
token=templateInfo.token;
return token;
}
case IDGENERATOR:
token=parseIdGeneratorTag(next());
return token;
case WIZACTION:
if (!jsdocBuilder.recordWizaction()) {
parser.addParserWarning("msg.jsdoc.wizaction",stream.getLineno(),stream.getCharno());
}
return eatUntilEOLIfNotAnnotation();
case DISPOSES:
{
ExtractionInfo templateInfo=extractSingleLineBlock();
List<String> names=Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string));
if (names.isEmpty() || names.get(0).isEmpty()) {
parser.addTypeWarning("msg.jsdoc.disposeparameter.missing",stream.getLineno(),stream.getCharno());
}
 else if (!jsdocBuilder.recordDisposesParameter(names)) {
parser.addTypeWarning("msg.jsdoc.disposeparameter.error",stream.getLineno(),stream.getCharno());
}
token=templateInfo.token;
return token;
}
case VERSION:
ExtractionInfo versionInfo=extractSingleLineBlock();
String version=versionInfo.string;
if (version.isEmpty()) {
parser.addParserWarning("msg.jsdoc.versionmissing",stream.getLineno(),stream.getCharno());
}
 else {
if (!jsdocBuilder.recordVersion(version)) {
parser.addParserWarning("msg.jsdoc.extraversion",stream.getLineno(),stream.getCharno());
}
}
token=versionInfo.token;
return token;
case CONSTANT:
case DEFINE:
case RETURN:
case PACKAGE:
case PRIVATE:
case PROTECTED:
case PUBLIC:
case THIS:
case TYPE:
case TYPEDEF:
lineno=stream.getLineno();
charno=stream.getCharno();
Node typeNode=null;
boolean hasType=lookAheadForType();
boolean isAlternateTypeAnnotation=(annotation == Annotation.PACKAGE || annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT);
boolean canSkipTypeAnnotation=(isAlternateTypeAnnotation || annotation == Annotation.RETURN);
type=null;
if (hasType || !canSkipTypeAnnotation) {
skipEOLs();
token=next();
typeNode=parseAndRecordTypeNode(token);
if (annotation == Annotation.THIS) {
typeNode=wrapNode(Token.BANG,typeNode);
}
type=createJSTypeExpression(typeNode);
}
boolean hasError=type == null && !canSkipTypeAnnotation;
if (!hasError) {
if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) {
if (!jsdocBuilder.recordType(type)) {
parser.addTypeWarning("msg.jsdoc.incompat.type",lineno,charno);
}
}
boolean isAnnotationNext=lookAheadForAnnotation();
switch (annotation) {
case CONSTANT:
if (!jsdocBuilder.recordConstancy()) {
parser.addParserWarning("msg.jsdoc.const",stream.getLineno(),stream.getCharno());
}
break;
case DEFINE:
if (!jsdocBuilder.recordDefineType(type)) {
parser.addParserWarning("msg.jsdoc.define",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PRIVATE:
if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
parser.addParserWarning("msg.jsdoc.visibility.private",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PACKAGE:
if (!jsdocBuilder.recordVisibility(Visibility.PACKAGE)) {
parser.addParserWarning("msg.jsdoc.visibility.package",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PROTECTED:
if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
parser.addParserWarning("msg.jsdoc.visibility.protected",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case PUBLIC:
if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
parser.addParserWarning("msg.jsdoc.visibility.public",lineno,charno);
}
if (!isAnnotationNext) {
return recordDescription(token);
}
break;
case RETURN:
if (type == null) {
type=createJSTypeExpression(newNode(Token.QMARK));
}
if (!jsdocBuilder.recordReturnType(type)) {
parser.addTypeWarning("msg.jsdoc.incompat.type",lineno,charno);
break;
}
if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) {
ExtractionInfo returnDescriptionInfo=extractMultilineTextualBlock(token);
String returnDescription=returnDescriptionInfo.string;
if (returnDescription.length() > 0) {
jsdocBuilder.recordReturnDescription(returnDescription);
}
token=returnDescriptionInfo.token;
}
 else {
token=eatUntilEOLIfNotAnnotation();
}
return token;
case THIS:
if (!jsdocBuilder.recordThisType(type)) {
parser.addTypeWarning("msg.jsdoc.incompat.type",lineno,charno);
}
break;
case TYPEDEF:
if (!jsdocBuilder.recordTypedef(type)) {
parser.addTypeWarning("msg.jsdoc.incompat.type",lineno,charno);
}
break;
}
}
return eatUntilEOLIfNotAnnotation();
}
}
return next();
}
