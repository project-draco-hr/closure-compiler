{
switch (node.getType()) {
case Token.RETURN:
{
      Node result=tryRemoveRedundantExit(node);
      if (result != node) {
        return result;
      }
      result=tryReplaceExitWithBreak(node);
      if (result != node) {
        return result;
      }
      return tryReduceReturn(node);
    }
case Token.THROW:
{
    Node result=tryRemoveRedundantExit(node);
    if (result != node) {
      return result;
    }
    return tryReplaceExitWithBreak(node);
  }
case Token.NOT:
tryMinimizeCondition(node.getFirstChild());
return tryMinimizeNot(node);
case Token.IF:
tryMinimizeCondition(node.getFirstChild());
return tryMinimizeIf(node);
case Token.EXPR_RESULT:
tryMinimizeCondition(node.getFirstChild());
return node;
case Token.HOOK:
tryMinimizeCondition(node.getFirstChild());
return node;
case Token.WHILE:
case Token.DO:
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
return node;
case Token.FOR:
if (!NodeUtil.isForIn(node)) {
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
}
return node;
case Token.TRUE:
case Token.FALSE:
return reduceTrueFalse(node);
case Token.NEW:
node=tryFoldStandardConstructors(node);
if (node.getType() != Token.CALL) {
return node;
}
case Token.CALL:
return tryFoldLiteralConstructor(node);
default :
return node;
}
}
